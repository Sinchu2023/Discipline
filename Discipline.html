<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Discipline Tracker Pro</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <style>
    :root {
      --bg-dark: #0a0a0a;
      --bg-darker: #080808;
      --card-bg: #1a1a1a;
      --border: #2a2a2a;
      --text-primary: #f5f5f7;
      --text-secondary: #a0a0a8;
      --text-accent: #ffffff;
      --success: #28a745;
      --warning: #ffc107;
      --danger: #dc3545;
      --primary: #007bff;
      --info: #17a2b8;
      --purple: #6f42c1;
      --yellow: #ffcc00;
      --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      --shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
      --shadow-hover: 0 12px 40px rgba(0, 0, 0, 0.4);
    }
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    }
    body {
      background: linear-gradient(135deg, #121212 0%, #0d0d0d 100%);
      color: var(--text-primary);
      min-height: 100vh;
      padding: 20px;
      line-height: 1.6;
      overflow-x: hidden;
    }
    .app-container {
      max-width: 1400px;
      margin: 0 auto;
      position: relative;
    }
    /* Header */
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1.5rem;
      margin-bottom: 2rem;
      background: rgba(25, 25, 25, 0.95);
      border-radius: 16px;
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .app-title {
      font-size: 1.8rem;
      font-weight: 700;
      letter-spacing: -0.5px;
      display: flex;
      align-items: center;
      gap: 12px;
      color: var(--text-accent);
    }
    .app-title i {
      color: var(--primary);
    }
    .view-controls {
      display: flex;
      gap: 12px;
    }
    .btn {
      background: linear-gradient(145deg, #2a2a2a, #222);
      color: var(--text-primary);
      border: 1px solid var(--border);
      padding: 10px 20px;
      border-radius: 10px;
      cursor: pointer;
      transition: var(--transition);
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 500;
      font-size: 0.95rem;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-hover);
      border-color: #3a3a3a;
    }
    .btn-primary {
      background: linear-gradient(145deg, #0066cc, #0052a3);
      border-color: #007bff;
    }
    .btn-success {
      background: linear-gradient(145deg, #28a745, #1e7e34);
      border-color: var(--success);
    }
    .btn-warning {
      background: linear-gradient(145deg, #ffc107, #e0a800);
      border-color: var(--warning);
    }
    .btn-danger {
      background: linear-gradient(145deg, #dc3545, #c82333);
      border-color: var(--danger);
    }
    /* Motivation Container */
    .motivation-container {
      text-align: center;
      padding: 1.5rem;
      margin: 0 auto 2.5rem;
      max-width: 900px;
      font-size: 1.1rem;
      border-radius: 16px;
      background: linear-gradient(135deg, rgba(25, 25, 25, 0.9), rgba(30, 30, 30, 0.9));
      border: 1px solid var(--border);
      position: relative;
      overflow: hidden;
      box-shadow: var(--shadow);
    }
    #motivation-line {
      transition: opacity 0.5s ease;
      font-weight: 500;
      letter-spacing: 0.3px;
    }
    /* Date Display */
    .date-display {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 2rem;
      padding: 1.2rem;
      background: rgba(25, 25, 25, 0.9);
      border-radius: 16px;
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
    }
    #current-date {
      font-size: 1.4rem;
      font-weight: 600;
      color: var(--text-accent);
    }
    #current-time {
      font-family: 'Courier New', monospace;
      font-size: 1.2rem;
      font-weight: 600;
      color: var(--primary);
      background: rgba(0, 123, 255, 0.1);
      padding: 8px 16px;
      border-radius: 8px;
      border: 1px solid rgba(0, 123, 255, 0.3);
    }
    /* Main Layout */
    .main-content {
      display: grid;
      grid-template-columns: 1fr 400px;
      gap: 2rem;
      margin-bottom: 2rem;
    }
    /* Stopwatch Container */
    .stopwatch-container {
      background: linear-gradient(135deg, rgba(25, 25, 25, 0.95), rgba(30, 30, 30, 0.95));
      border-radius: 20px;
      padding: 2rem;
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
    }
    .stopwatch-display {
      font-size: 4rem;
      font-family: 'Courier New', monospace;
      font-weight: 700;
      text-align: center;
      color: var(--primary);
      margin: 1.5rem 0;
      padding: 1.5rem;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 16px;
      border: 2px solid var(--border);
      text-shadow: 0 0 20px rgba(0, 123, 255, 0.3);
      letter-spacing: 2px;
    }
    .task-input-container {
      display: flex;
      gap: 12px;
      margin: 2rem 0;
    }
    .task-input {
      flex: 1;
      padding: 1rem 1.5rem;
      font-size: 1.1rem;
      background: rgba(15, 15, 15, 0.8);
      border: 2px solid var(--border);
      border-radius: 12px;
      color: var(--text-primary);
      transition: var(--transition);
    }
    .task-input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
    }
    .controls-container {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      margin-bottom: 2rem;
    }
    .controls-container .btn {
      padding: 1rem;
      font-size: 1.1rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }
    .active-task-indicator {
      background: linear-gradient(135deg, rgba(40, 167, 69, 0.1), rgba(25, 135, 84, 0.1));
      border: 1px solid var(--success);
      border-radius: 12px;
      padding: 1.5rem;
      margin: 1.5rem 0;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.4); }
      70% { box-shadow: 0 0 0 10px rgba(40, 167, 69, 0); }
      100% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0); }
    }
    /* Favorites Section */
    .section-title {
      font-size: 1.2rem;
      font-weight: 600;
      color: var(--text-accent);
      margin: 2rem 0 1rem;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .favorites-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 10px;
      margin-bottom: 2rem;
    }
    .favorite-card {
      background: rgba(30, 30, 30, 0.8);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1rem;
      cursor: pointer;
      transition: var(--transition);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .favorite-card:hover {
      transform: translateY(-3px);
      background: rgba(40, 40, 40, 0.9);
      border-color: var(--primary);
    }
    .favorite-name {
      font-weight: 500;
    }
    .favorite-actions {
      display: flex;
      gap: 8px;
    }
    /* Today's Tasks */
    .tasks-list {
      max-height: 400px;
      overflow-y: auto;
      padding-right: 8px;
    }
    .tasks-list::-webkit-scrollbar {
      width: 6px;
    }
    .tasks-list::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 3px;
    }
    .tasks-list::-webkit-scrollbar-thumb {
      background: var(--primary);
      border-radius: 3px;
    }
    .task-card {
      background: rgba(30, 30, 30, 0.8);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1.2rem;
      margin-bottom: 10px;
      transition: var(--transition);
    }
    .task-card:hover {
      transform: translateX(5px);
      background: rgba(40, 40, 40, 0.9);
    }
    .task-card.sleep {
      border-left: 4px solid var(--purple);
    }
    .task-card.productive {
      border-left: 4px solid var(--success);
    }
    .task-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .task-name {
      font-weight: 600;
      font-size: 1.1rem;
    }
    .task-duration {
      font-family: 'Courier New', monospace;
      font-weight: 600;
      color: var(--primary);
    }
    .task-time {
      font-size: 0.9rem;
      color: var(--text-secondary);
      margin-bottom: 8px;
    }
    .task-actions {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }
    /* Stats Dashboard */
    .stats-dashboard {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 1.5rem;
      margin-bottom: 2rem;
    }
    .stat-card {
      background: linear-gradient(135deg, rgba(25, 25, 25, 0.9), rgba(30, 30, 30, 0.9));
      border-radius: 16px;
      padding: 1.5rem;
      border: 1px solid var(--border);
    }
    .stat-value {
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 8px;
    }
    .stat-label {
      font-size: 0.95rem;
      color: var(--text-secondary);
    }
    .stat-productive { color: var(--success); }
    .stat-sleep { color: var(--purple); }
    .stat-total { color: var(--primary); }
    .stat-streak { color: var(--warning); }

    /* Shadow Engine */
    .shadow-section {
      margin-bottom: 2rem;
    }
    .shadow-title {
      font-size: 1.15rem;
      font-weight: 700;
      letter-spacing: 0.8px;
      margin-bottom: 1rem;
      color: var(--text-accent);
    }
    .shadow-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 1rem;
    }
    .shadow-card {
      background: linear-gradient(145deg, rgba(18, 18, 18, 0.95), rgba(24, 24, 24, 0.95));
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 1.25rem;
      box-shadow: var(--shadow);
      transition: transform 320ms ease, box-shadow 320ms ease, border-color 320ms ease;
    }
    .shadow-card:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-hover);
      border-color: rgba(255, 255, 255, 0.12);
    }
    .shadow-card-title {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.6px;
      color: var(--text-secondary);
      margin-bottom: 0.85rem;
    }
    .shadow-main-value {
      font-size: 2rem;
      font-weight: 700;
      margin-bottom: 0.35rem;
      color: var(--text-accent);
    }
    .shadow-line {
      font-size: 0.9rem;
      color: var(--text-secondary);
      margin-bottom: 0.45rem;
    }
    .shadow-gap-positive { color: var(--danger); }
    .shadow-gap-negative { color: var(--success); }
    .shadow-gap-equal { color: var(--text-secondary); }
    .shadow-momentum-positive { color: var(--success); }
    .shadow-momentum-negative { color: var(--danger); }
    .shadow-momentum-flat { color: var(--warning); }
    .shadow-badge {
      display: inline-flex;
      padding: 5px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.05);
      font-size: 0.8rem;
      color: var(--text-primary);
      margin-top: 0.25rem;
      margin-right: 0.5rem;
    }
    .shadow-progress {
      margin-top: 0.75rem;
      height: 8px;
      width: 100%;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }
    .shadow-progress-fill {
      width: 0%;
      height: 100%;
      border-radius: inherit;
      transition: width 420ms ease, background 420ms ease, box-shadow 420ms ease;
      background: #dc3545;
    }
    .shadow-new-standard {
      animation: shadowPulse 520ms ease;
    }
    @keyframes shadowPulse {
      0% { box-shadow: var(--shadow); border-color: var(--border); }
      50% { box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.25), var(--shadow-hover); border-color: rgba(40, 167, 69, 0.7); }
      100% { box-shadow: var(--shadow); border-color: var(--border); }
    }
    /* Graphs Container */
    .graphs-container {
      display: flex;
      flex-direction: column;
      gap: 2rem;
    }
    .graph-card {
      background: linear-gradient(160deg, rgba(22, 24, 30, 0.95), rgba(17, 18, 22, 0.96));
      border-radius: 20px;
      padding: 1.5rem;
      border: 1px solid rgba(255, 255, 255, 0.06);
      box-shadow: 0 14px 36px rgba(0, 0, 0, 0.35);
      animation: graphFadeIn 400ms ease, graphSlideUp 500ms ease;
      transition: transform 350ms ease, box-shadow 350ms ease, border-color 350ms ease;
      will-change: transform, box-shadow;
    }
    .graph-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 18px 44px rgba(0, 0, 0, 0.42);
      border-color: rgba(0, 123, 255, 0.25);
    }
    .graph-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      gap: 10px;
      flex-wrap: wrap;
    }
    .graph-title {
      font-size: 1.2rem;
      font-weight: 600;
      color: var(--text-accent);
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .graph-controls {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    .range-select {
      background: rgba(12, 12, 15, 0.9);
      color: var(--text-primary);
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 8px 12px;
      border-radius: 10px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: border-color 300ms ease, box-shadow 300ms ease, transform 300ms ease;
    }
    .range-select:hover {
      border-color: rgba(0, 123, 255, 0.35);
      transform: translateY(-1px);
    }
    .range-select:focus {
      outline: none;
      border-color: rgba(0, 123, 255, 0.65);
      box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.12);
    }
    .graph-canvas-container {
      position: relative;
      height: 250px;
      width: 100%;
      transition: opacity 350ms ease, transform 350ms ease;
    }
    .graph-canvas-container.filter-updating {
      opacity: 0.55;
      transform: translateY(4px);
    }
    .prod-total-counter {
      min-width: 100px;
      text-align: right;
      font-weight: 600;
      color: #98f5a7;
      font-family: 'Courier New', monospace;
      letter-spacing: 0.3px;
    }
    @keyframes graphFadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    @keyframes graphSlideUp {
      from { transform: translateY(10px); }
      to { transform: translateY(0); }
    }
    /* Streak Popup */
    .streak-popup-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      backdrop-filter: blur(5px);
    }
    .streak-popup {
      background: linear-gradient(135deg, #1a1a1a, #222);
      border-radius: 24px;
      padding: 3rem;
      max-width: 500px;
      width: 90%;
      text-align: center;
      border: 1px solid var(--border);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      animation: popupAppear 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    @keyframes popupAppear {
      from { transform: scale(0.8); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }
    .streak-icon {
      font-size: 4rem;
      color: var(--warning);
      margin-bottom: 1.5rem;
    }
    .streak-count {
      font-size: 5rem;
      font-weight: 800;
      color: var(--warning);
      margin: 1rem 0;
      text-shadow: 0 0 30px rgba(255, 204, 0, 0.3);
    }
    .streak-message {
      font-size: 1.2rem;
      color: var(--text-primary);
      margin: 1.5rem 0;
      line-height: 1.6;
    }
    /* Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      padding: 20px;
    }
    .modal {
      background: linear-gradient(135deg, #1a1a1a, #222);
      border-radius: 20px;
      max-width: 900px;
      width: 100%;
      max-height: 90vh;
      overflow: hidden;
      border: 1px solid var(--border);
    }
    .modal-header {
      padding: 2rem;
      border-bottom: 1px solid var(--border);
      background: rgba(30, 30, 30, 0.9);
    }
    .modal-title {
      font-size: 1.8rem;
      font-weight: 700;
      color: var(--text-accent);
    }
    .modal-content {
      padding: 2rem;
      overflow-y: auto;
      max-height: 60vh;
    }
    .modal-footer {
      padding: 1.5rem 2rem;
      border-top: 1px solid var(--border);
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      background: rgba(30, 30, 30, 0.9);
    }
    /* Responsive Design */
    @media (max-width: 1200px) {
      .main-content {
        grid-template-columns: 1fr;
      }
    }
    @media (max-width: 768px) {
      body {
        padding: 12px;
      }
      .stopwatch-display {
        font-size: 3rem;
      }
      .controls-container {
        grid-template-columns: 1fr;
      }
      .stats-dashboard {
        grid-template-columns: 1fr;
      }
      .shadow-grid {
        grid-template-columns: 1fr;
      }
      .favorites-grid {
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      }
      .task-input-container {
        flex-direction: column;
      }
    }
    @media (max-width: 480px) {
      header {
        flex-direction: column;
        gap: 1rem;
      }
      .app-title {
        font-size: 1.4rem;
      }
      .stopwatch-display {
        font-size: 2.5rem;
      }
      .motivation-container {
        padding: 1rem;
        font-size: 1rem;
      }
      .date-display {
        flex-direction: column;
        gap: 1rem;
        text-align: center;
      }
    }
  </style>
</head>
<body>
  <!-- Streak Popup -->
  <div class="streak-popup-overlay" id="streak-popup">
    <div class="streak-popup">
      <div class="streak-icon">
        <i class="fas fa-fire"></i>
      </div>
      <h2>STREAK MAINTAINED</h2>
      <div class="streak-count" id="streak-count">0</div>
      <div class="streak-message" id="streak-message"></div>
      <button class="btn btn-primary" id="close-streak">CONTINUE</button>
    </div>
  </div>
  <!-- Motivation -->
  <div class="motivation-container">
    <div id="motivation-line">Excellence is not a singular act, but a habit. You are what you repeatedly do.</div>
  </div>
  <!-- Main App Container -->
  <div class="app-container">
    <!-- Header -->
    <header>
      <h1 class="app-title">
        <i class="fas fa-stopwatch"></i> DISCIPLINE TRACKER PRO
      </h1>
      <div class="view-controls">
        <button class="btn btn-primary" id="view-report">
          <i class="fas fa-chart-bar"></i> Report
        </button>
        <button class="btn" id="export-data">
          <i class="fas fa-download"></i> Export
        </button>
      </div>
    </header>
    <!-- Date and Time Display -->
    <div class="date-display">
      <div id="current-date">February 8, 2026</div>
      <div id="current-time">14:30:45</div>
    </div>
    <!-- Stats Dashboard -->
    <div class="stats-dashboard">
      <div class="stat-card">
        <div class="stat-value stat-productive" id="productive-time">0h 0m</div>
        <div class="stat-label">Productive Today</div>
      </div>
      <div class="stat-card">
        <div class="stat-value stat-sleep" id="sleep-time">0h 0m</div>
        <div class="stat-label">Sleep Today</div>
      </div>
      <div class="stat-card">
        <div class="stat-value stat-total" id="total-time">0h 0m</div>
        <div class="stat-label">Total Tracked</div>
      </div>
      <div class="stat-card">
        <div class="stat-value stat-streak" id="streak-display">0</div>
        <div class="stat-label">Day Streak</div>
      </div>
    </div>

    <!-- SHADOW Engine -->
    <section class="shadow-section">
      <h2 class="shadow-title">SHADOW</h2>
      <div class="shadow-grid">
        <div class="shadow-card" id="shadow-current-card">
          <div class="shadow-card-title">âš” Current You</div>
          <div class="shadow-main-value" id="shadow-current-minutes">0h 00m</div>
          <div class="shadow-line">Weekly 7-Day Avg: <strong id="shadow-weekly-average">0h 00m</strong></div>
          <div class="shadow-line">Momentum: <strong id="shadow-momentum" class="shadow-momentum-flat">Stable</strong></div>
          <div class="shadow-line">Gap vs Shadow: <strong id="shadow-gap" class="shadow-gap-equal">0h 00m</strong></div>
          <div class="shadow-line">Reached: <strong id="shadow-percent">0%</strong></div>
          <div>
            <span class="shadow-badge" id="shadow-status">Below Identity</span>
          </div>
          <div class="shadow-progress">
            <div class="shadow-progress-fill" id="shadow-progress-fill"></div>
          </div>
        </div>
        <div class="shadow-card" id="shadow-standard-card">
          <div class="shadow-card-title">ðŸŒ‘ The Shadow</div>
          <div class="shadow-main-value" id="shadow-average">0h 00m</div>
          <div>
            <span class="shadow-badge" id="shadow-rank">Rank: Recruit</span>
          </div>
          <div>
            <span class="shadow-badge" id="shadow-badge">Builder</span>
          </div>
          <div class="shadow-line">Your Strongest Historical 7-Day Standard</div>
          <div class="shadow-line" id="shadow-note">Calculated from real historical data only</div>
        </div>
      </div>
    </section>
    <!-- Main Content -->
    <div class="main-content">
      <!-- Stopwatch Section -->
      <div class="stopwatch-container">
        <!-- Stopwatch Display -->
        <div class="stopwatch-display" id="stopwatch">00:00:00</div>
        <!-- Task Input -->
        <div class="task-input-container">
          <input type="text" class="task-input" id="task-input" placeholder="Enter task name..." maxlength="50" />
          <button class="btn btn-success" id="add-favorite" title="Add to favorites">
            <i class="far fa-star"></i>
          </button>
        </div>
        <!-- Controls -->
        <div class="controls-container">
          <button class="btn btn-success" id="start-btn">
            <i class="fas fa-play"></i>
            <span>Start</span>
          </button>
          <button class="btn btn-danger" id="stop-btn" disabled>
            <i class="fas fa-stop"></i>
            <span>Stop</span>
          </button>
          <button class="btn btn-primary" id="sleep-btn">
            <i class="fas fa-bed"></i>
            <span>Sleep</span>
          </button>
        </div>
        <!-- Active Task Indicator -->
        <div id="active-task-indicator" style="display: none;">
          <div class="active-task-indicator">
            <strong><i class="fas fa-running"></i> Active Task:</strong>
            <span id="active-task-name"></span>
            <br>
            <small>Started at: <span id="active-task-start"></span></small>
          </div>
        </div>
        <!-- Favorites Section -->
        <h3 class="section-title">
          <i class="fas fa-star"></i> Quick Start Favorites
        </h3>
        <div class="favorites-grid" id="favorites-grid">
          <!-- Favorites will be dynamically inserted here -->
        </div>
        <!-- Today's Tasks -->
        <h3 class="section-title">
          <i class="fas fa-tasks"></i> Today's Activities
        </h3>
        <div class="tasks-list" id="tasks-list">
          <!-- Tasks will be dynamically inserted here -->
        </div>
      </div>
      <!-- Graphs Section -->
      <div class="graphs-container">
        <!-- Productivity Graph -->
        <div class="graph-card">
          <div class="graph-header">
            <div class="graph-title">
              <i class="fas fa-chart-line"></i>
              Productivity Trend
            </div>
            <div class="graph-controls">
              <select class="range-select" id="prod-range">
                <option value="7d">7 Days</option>
                <option value="30d">30 Days</option>
                <option value="3m">3 Months</option>
                <option value="6m">6 Months</option>
                <option value="1y">1 Year</option>
              </select>
              <select class="range-select" id="prod-filter">
                <option value="all">All</option>
                <option value="productivity">Productivity</option>
                <option value="distraction">Distraction</option>
                <option value="neutral">Neutral</option>
                <option value="high_waste">High Waste Only</option>
              </select>
              <span class="prod-total-counter" id="prod-filter-total">0h 00m</span>
            </div>
          </div>
          <div class="graph-canvas-container">
            <canvas id="productivity-chart"></canvas>
          </div>
        </div>
        <!-- Sleep Graph -->
        <div class="graph-card">
          <div class="graph-header">
            <div class="graph-title">
              <i class="fas fa-bed"></i>
              Sleep Analysis
            </div>
            <div class="graph-controls">
              <select class="range-select" id="sleep-range">
                <option value="7d">7 Days</option>
                <option value="30d">30 Days</option>
                <option value="3m">3 Months</option>
                <option value="6m">6 Months</option>
                <option value="1y">1 Year</option>
              </select>
            </div>
          </div>
          <div class="graph-canvas-container">
            <canvas id="sleep-chart"></canvas>
          </div>
        </div>
      </div>
    </div>
  </div>
  <!-- Report Modal -->
  <div class="modal-overlay" id="report-modal">
    <div class="modal">
      <div class="modal-header">
        <h2 class="modal-title">Performance Report</h2>
        <button class="btn" id="close-modal" style="position: absolute; right: 20px; top: 20px;">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div class="modal-content" id="report-content">
        <!-- Report content will be dynamically inserted -->
      </div>
      <div class="modal-footer">
        <button class="btn" id="print-report">
          <i class="fas fa-print"></i> Print
        </button>
        <button class="btn btn-primary" id="close-report">
          Close
        </button>
      </div>
    </div>
  </div>
  <script>
    // ==============================================
    // Discipline Tracker Pro - Extended Logic/Data/Reporting
    // ==============================================
    const CONFIG = {
      DB_SCHEMA_VERSION: 2,
      DAILY_PRODUCTIVITY_THRESHOLD_MINUTES: 240,
      STORAGE_KEYS: {
        TASKS: 'discipline_tracker_tasks',
        FAVORITES: 'discipline_tracker_favorites',
        STREAK: 'discipline_tracker_streak',
        LAST_ACTIVITY: 'discipline_tracker_last_activity',
        ACTIVE_TASK: 'discipline_tracker_active_task',
        SCHEMA_VERSION: 'discipline_tracker_schema_version',
        SYNC_ENDPOINT: 'discipline_tracker_sync_endpoint',
        SYNC_DEVICE_ID: 'discipline_tracker_device_id',
        SYNC_QUEUE: 'discipline_tracker_sync_queue',
        SHADOW_AVG: 'discipline_tracker_shadow_avg'
      },
      MOTIVATION_INTERVAL: 15000,
      CHART_RANGES: { '7d': 7, '30d': 30, '3m': 90, '6m': 180, '1y': 365 }
    };
    const CATEGORY_DEFINITIONS = {
      'Sleep': ['Night Sleep', 'Nap', 'Recovery'],
      'Productive Work': ['Analog', 'PCB', 'Coding', 'Control Systems', 'Planning', 'Execution'],
      'Physical Training': ['Chest', 'Back', 'Legs', 'Arms', 'Conditioning', 'Mobility'],
      'Study / Skill Development': ['Reading', 'Course', 'Practice', 'Research'],
      'Time Waste / Distraction': ['Social Media', 'Streaming', 'Gaming', 'Browsing', 'Idle'],
      'Miscellaneous': ['Admin', 'Commute', 'Family', 'Other']
    };
    const CATEGORY_ALIASES = {
      sleep: 'Sleep',
      rest: 'Sleep',
      productive: 'Productive Work',
      work: 'Productive Work',
      training: 'Physical Training',
      physical: 'Physical Training',
      workout: 'Physical Training',
      study: 'Study / Skill Development',
      skill: 'Study / Skill Development',
      learning: 'Study / Skill Development',
      waste: 'Time Waste / Distraction',
      distraction: 'Time Waste / Distraction',
      misc: 'Miscellaneous',
      miscellaneous: 'Miscellaneous'
    };
    const PRODUCTIVE_CATEGORIES = new Set(['Productive Work', 'Physical Training', 'Study / Skill Development']);
    // Logical schema (local + cloud payload)
    // activity_entry: {
    //   id, category, subcategory, startTime, endTime, duration, date,
    //   description(optional), sourceDevice, createdAt, updatedAt
    // }
    const MOTIVATION_LINES = [
      "Excellence is not a singular act, but a habit. You are what you repeatedly do.",
      "Discipline is the bridge between goals and accomplishment.",
      "The comeback is always stronger than the setback. Keep grinding.",
      "No shortcuts. No excuses. Just relentless execution.",
      "Consistency beats intensity every single time. Show up daily.",
      "Pain is temporary. Quitting lasts forever. Choose your hard.",
      "Your discipline today is your freedom tomorrow.",
      "Grind in silence, let success make the noise.",
      "Fall seven times, stand up eight. This is discipline.",
      "Small daily improvements lead to staggering long-term results.",
      "The only limit is the one you set yourself. Break it.",
      "Action is the antidote to anxiety. Keep moving forward.",
      "Don't stop when you're tired. Stop when you're done.",
      "The only bad workout is the one that didn't happen.",
      "Success is the sum of small efforts, repeated day in and day out.",
      "Your future is created by what you do today, not tomorrow.",
      "The harder you work for something, the greater you'll feel when you achieve it.",
      "Discipline is doing what needs to be done even when you don't want to.",
      "Be so good they can't ignore you. Master your craft.",
      "The only way to achieve the impossible is to believe it is possible."
    ];
    const STREAK_MESSAGES = {
      1: "Day one. This is where it begins.", 3: "Three days strong. Momentum is building.",
      7: "One week! Discipline is becoming a habit.", 14: "Two weeks. You're building something real.",
      21: "Three weeks. This is who you are now.", 30: "One month of discipline. Elite status.",
      60: "Two months. You've transformed.", 90: "Three months. Unstoppable.",
      100: "Century streak. This is your identity.", 365: "One year. You've mastered yourself."
    };

    class ActivityClassifier {
      static classify(activityInput) {
        const activity = (activityInput || '').trim();
        const text = activity.toLowerCase();

        const strongDistraction = ['random', 'scrolling', 'reels', 'timepass', 'doomscroll', 'binge', 'procrastination'];
        const distractionKeywords = ['instagram', 'tiktok', 'youtube shorts', 'gaming', 'games', 'twitter', 'x app', 'reddit', 'netflix', 'series', 'memes', 'chatting'];
        const productiveKeywords = ['coding', 'project', 'study', 'learning', 'course', 'workout', 'exercise', 'gym', 'chest', 'back', 'legs', 'pcb', 'analog', 'control systems', 'research', 'writing', 'build'];
        const neutralKeywords = ['commute', 'cleaning', 'meal', 'eating', 'shopping', 'family', 'chores', 'admin', 'errands', 'restroom'];

        let productiveScore = 0;
        let distractionScore = 0;
        let neutralScore = 0;

        strongDistraction.forEach(k => { if (text.includes(k)) distractionScore += 5; });
        distractionKeywords.forEach(k => { if (text.includes(k)) distractionScore += 3; });
        productiveKeywords.forEach(k => { if (text.includes(k)) productiveScore += 3; });
        neutralKeywords.forEach(k => { if (text.includes(k)) neutralScore += 2; });

        if (!text) neutralScore += 1;

        let category = 'NEUTRAL';
        let graph_tag = 'neutral';
        if (distractionScore > productiveScore && distractionScore >= neutralScore) {
          category = 'DISTRACTION';
          graph_tag = 'distraction';
        } else if (productiveScore > distractionScore && productiveScore >= neutralScore) {
          category = 'PRODUCTIVE';
          graph_tag = 'productivity';
        }

        const maxScore = Math.max(productiveScore, distractionScore, neutralScore, 1);
        const secondScore = [productiveScore, distractionScore, neutralScore].sort((a, b) => b - a)[1] || 0;
        const confidence = Math.max(40, Math.min(100, Math.round(55 + (maxScore - secondScore) * 9)));

        let waste_level = 'NONE';
        if (category === 'DISTRACTION') {
          if (strongDistraction.some(k => text.includes(k)) || distractionScore >= 8) waste_level = 'HIGH';
          else if (distractionScore >= 5) waste_level = 'MODERATE';
          else waste_level = 'LOW';
        }

        return {
          activity,
          category,
          confidence,
          waste_level,
          graph_tag
        };
      }
    }
    class SyncManager {
      constructor(app) { this.app = app; }
      get endpoint() { return localStorage.getItem(CONFIG.STORAGE_KEYS.SYNC_ENDPOINT); }
      getDeviceId() {
        let id = localStorage.getItem(CONFIG.STORAGE_KEYS.SYNC_DEVICE_ID);
        if (!id) {
          id = `device-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
          localStorage.setItem(CONFIG.STORAGE_KEYS.SYNC_DEVICE_ID, id);
        }
        return id;
      }
      queue(change) {
        const q = this.app.loadFromStorage(CONFIG.STORAGE_KEYS.SYNC_QUEUE) || [];
        q.push(change);
        this.app.saveToStorage(CONFIG.STORAGE_KEYS.SYNC_QUEUE, q);
      }
      async flushQueue() {
        if (!navigator.onLine || !this.endpoint) return;
        const queue = this.app.loadFromStorage(CONFIG.STORAGE_KEYS.SYNC_QUEUE) || [];
        if (!queue.length) return;
        try {
          await fetch(this.endpoint, {
            method: 'POST', headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ deviceId: this.getDeviceId(), changes: queue })
          });
          this.app.saveToStorage(CONFIG.STORAGE_KEYS.SYNC_QUEUE, []);
        } catch (e) { console.warn('Sync flush failed:', e); }
      }
      async pullLatest() {
        if (!navigator.onLine || !this.endpoint) return;
        try {
          const res = await fetch(`${this.endpoint}?deviceId=${encodeURIComponent(this.getDeviceId())}`);
          if (!res.ok) return;
          const payload = await res.json();
          if (!Array.isArray(payload.entries)) return;
          this.app.taskManager.mergeTasks(payload.entries.map(t => this.app.normalizeTask(t)));
        } catch (e) { console.warn('Cloud pull failed:', e); }
      }
      async syncNow() { await this.flushQueue(); await this.pullLatest(); }
    }
    class DisciplineTracker {
      constructor() {
        this.state = {
          tasks: (this.loadFromStorage(CONFIG.STORAGE_KEYS.TASKS) || []).map(t => this.normalizeTask(t)),
          favorites: this.loadFromStorage(CONFIG.STORAGE_KEYS.FAVORITES) || [],
          streak: parseInt(this.loadFromStorage(CONFIG.STORAGE_KEYS.STREAK)) || 0,
          lastActivityDate: this.loadFromStorage(CONFIG.STORAGE_KEYS.LAST_ACTIVITY),
          activeTask: this.loadFromStorage(CONFIG.STORAGE_KEYS.ACTIVE_TASK),
          charts: { productivity: null, sleep: null }
        };
        this.elements = this.initializeElements();
        this.syncManager = new SyncManager(this);
        this.stopwatch = new StopwatchManager(this);
        this.taskManager = new TaskManager(this);
        this.uiManager = new UIManager(this);
        this.shadowEngine = new ShadowEngine(this);
        this.graphManager = new GraphManager(this);
        this.eventManager = new EventManager(this);
        this.migrateSchema();
      }
      initializeElements() {
        const elements = {};
        ['stopwatch','task-input','start-btn','stop-btn','sleep-btn','add-favorite','active-task-indicator','active-task-name','active-task-start','favorites-grid','tasks-list','productive-time','sleep-time','total-time','streak-display','current-date','current-time','motivation-line','prod-range','prod-filter','prod-filter-total','sleep-range','productivity-chart','sleep-chart','streak-popup','streak-count','streak-message','close-streak','view-report','export-data','report-modal','report-content','close-modal','print-report','close-report','shadow-current-card','shadow-standard-card','shadow-current-minutes','shadow-percent','shadow-gap','shadow-status','shadow-progress-fill','shadow-average','shadow-rank','shadow-badge','shadow-note','shadow-weekly-average','shadow-momentum'].forEach(id => elements[id] = document.getElementById(id));
        return elements;
      }
      loadFromStorage(key) { try { const d = localStorage.getItem(key); return d ? JSON.parse(d) : null; } catch { return null; } }
      saveToStorage(key, data) { try { localStorage.setItem(key, JSON.stringify(data)); } catch (e) { console.error('storage save failed', e); } }
      migrateSchema() {
        const current = parseInt(this.loadFromStorage(CONFIG.STORAGE_KEYS.SCHEMA_VERSION)) || 1;
        if (current < CONFIG.DB_SCHEMA_VERSION) {
          this.state.tasks = this.state.tasks.map(t => this.normalizeTask(t));
          this.saveToStorage(CONFIG.STORAGE_KEYS.TASKS, this.state.tasks);
          this.saveToStorage(CONFIG.STORAGE_KEYS.SCHEMA_VERSION, CONFIG.DB_SCHEMA_VERSION);
        }
      }
      normalizeTask(task) {
        const isLegacySleep = task.isSleep === true || task.category === 'Sleep';
        const category = this.resolveCategory(task.category || (isLegacySleep ? 'Sleep' : 'Miscellaneous'));
        const fallbackSub = CATEGORY_DEFINITIONS[category]?.[0] || 'General';
        const subcategory = task.subcategory || (isLegacySleep ? 'Night Sleep' : fallbackSub);
        const description = task.description || task.name || '';
        const startTime = Number(task.startTime || Date.now());
        const endTime = Number(task.endTime || startTime);
        const duration = Math.max(0, task.duration ?? Math.round((endTime - startTime) / 60000));

        const classifierInput = (task.description || task.name || '').trim();
        const classification = ActivityClassifier.classify(classifierInput);

        // Context-aware correction so graph filters remain reliable:
        // category intent from user selection is respected over weak text hints.
        if (category === 'Time Waste / Distraction') {
          classification.category = 'DISTRACTION';
          classification.graph_tag = 'distraction';
          if (classification.waste_level === 'NONE') classification.waste_level = duration >= 90 ? 'HIGH' : (duration >= 30 ? 'MODERATE' : 'LOW');
          classification.confidence = Math.max(75, classification.confidence);
        } else if (PRODUCTIVE_CATEGORIES.has(category)) {
          classification.category = 'PRODUCTIVE';
          classification.graph_tag = 'productivity';
          classification.waste_level = 'NONE';
          classification.confidence = Math.max(70, classification.confidence);
        } else if (category === 'Sleep' || category === 'Miscellaneous') {
          classification.category = 'NEUTRAL';
          classification.graph_tag = 'neutral';
          classification.waste_level = 'NONE';
          classification.confidence = Math.max(60, classification.confidence);
        }

        const graphTag = task.graph_tag || classification.graph_tag;
        const wasteLevel = task.waste_level || classification.waste_level;
        const growthCategory = task.growth_category || classification.category;
        const confidence = Number(task.confidence ?? classification.confidence);

        return {
          id: task.id || `${startTime}-${Math.random().toString(36).slice(2, 8)}`,
          category, subcategory, description,
          startTime, endTime, duration,
          date: task.date || this.getDateString(new Date(startTime)),
          sourceDevice: task.sourceDevice || this.syncManager?.getDeviceId?.() || 'local',
          createdAt: task.createdAt || Date.now(),
          updatedAt: Date.now(),
          growth_category: growthCategory,
          confidence,
          waste_level: wasteLevel,
          graph_tag: graphTag,
          classification_json: {
            activity: task.description || task.name || '',
            category: growthCategory,
            confidence,
            waste_level: wasteLevel,
            graph_tag: graphTag
          }
        };
      }
      getDateString(date = new Date()) { const d = new Date(date); return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`; }
      formatDuration(minutes) { const h=Math.floor(minutes/60),m=Math.floor(minutes%60); return `${h}h ${String(m).padStart(2,'0')}m`; }
      formatTime(ts) { return new Date(ts).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); }
      isProductiveCategory(category) { return PRODUCTIVE_CATEGORIES.has(category); }
      resolveCategory(inputCategory) {
        const categories = Object.keys(CATEGORY_DEFINITIONS);
        if (!inputCategory) return 'Miscellaneous';
        const normalized = String(inputCategory).trim().toLowerCase();
        const exact = categories.find(c => c.toLowerCase() === normalized);
        if (exact) return exact;
        if (CATEGORY_ALIASES[normalized]) return CATEGORY_ALIASES[normalized];
        const loose = categories.find(c => c.toLowerCase().includes(normalized) || normalized.includes(c.toLowerCase()));
        return loose || 'Miscellaneous';
      }
      async initialize() {
        if (!window.Chart) { try { await this.loadChartJS(); } catch {} }
        this.uiManager.initialize(); this.taskManager.initialize(); this.shadowEngine.initialize(); this.graphManager.initialize(); this.eventManager.initialize();
        this.updateStreak();
        if (this.state.activeTask) this.stopwatch.resumeActiveTask(this.state.activeTask);
        window.addEventListener('online', () => this.syncManager.syncNow());
        await this.syncManager.syncNow();
      }
      loadChartJS() { return new Promise((resolve, reject) => { const s=document.createElement('script'); s.src='https://cdn.jsdelivr.net/npm/chart.js'; s.onload=resolve; s.onerror=reject; document.head.appendChild(s); }); }
      updateStreak(showPopup = false) {
        const dates = [...new Set(this.state.tasks.map(t => t.date))].sort();
        if (!dates.length) { this.state.streak=0; this.elements['streak-display'].textContent=0; return; }
        const set = new Set(dates); const today = this.getDateString();
        let streak=0; let cursor=set.has(today)?today:this.getDateString(new Date(Date.now()-86400000));
        while (set.has(cursor)) { streak++; const d=new Date(cursor); d.setDate(d.getDate()-1); cursor=this.getDateString(d); }
        const old=this.state.streak; this.state.streak=streak;
        this.saveToStorage(CONFIG.STORAGE_KEYS.STREAK, streak); this.elements['streak-display'].textContent=streak;
        if (showPopup && streak > old && streak > 1) this.uiManager.showStreakPopup();
      }
    }
    class StopwatchManager {
      constructor(app) { this.app = app; this.startTime = null; this.elapsedTime = 0; this.animationFrameId = null; this.isRunning = false; this.pendingMeta = null; }
      collectEntryMetadata(taskName, forceCategory = null) {
        const categories = Object.keys(CATEGORY_DEFINITIONS);
        const defaultCategory = forceCategory || 'Productive Work';
        const categoryInput = prompt(`Category (${categories.join(' | ')})`, defaultCategory);
        if (categoryInput === null) return null;
        const category = this.app.resolveCategory(categoryInput) || defaultCategory;
        const subList = CATEGORY_DEFINITIONS[category] || ['General'];
        const subInput = prompt(`Subcategory for ${category} (${subList.join(' | ')})`, subList[0]);
        if (subInput === null) return null;
        const subcategory = subInput.trim() || subList[0];
        const description = (this.app.elements['task-input'].value.trim() || taskName || '').slice(0, 120);
        return { category, subcategory, description };
      }
      start(taskName = null, meta = null) {
        if (this.isRunning) return alert('A task is already running. Stop it first.');
        const name = taskName || this.app.elements['task-input'].value.trim();
        if (!name && !meta) return alert('Please enter a task name');
        const resolvedMeta = meta || this.collectEntryMetadata(name, null);
        if (!resolvedMeta) return;
        this.startTime = Date.now(); this.isRunning = true; this.elapsedTime = 0;
        this.app.state.activeTask = { name: name || resolvedMeta.subcategory, startTime: this.startTime, ...resolvedMeta };
        this.app.saveToStorage(CONFIG.STORAGE_KEYS.ACTIVE_TASK, this.app.state.activeTask);
        this.app.elements['start-btn'].disabled = true; this.app.elements['stop-btn'].disabled = false; this.app.elements['task-input'].disabled = true;
        this.app.elements['active-task-name'].textContent = `${this.app.state.activeTask.category} â€¢ ${this.app.state.activeTask.subcategory}`;
        this.app.elements['active-task-start'].textContent = this.app.formatTime(this.startTime); this.app.elements['active-task-indicator'].style.display = 'block';
        this.update();
      }
      startSleep() { this.start('Sleep', { category: 'Sleep', subcategory: 'Night Sleep', description: 'Sleep Session' }); }
      update() {
        if (!this.isRunning) return;
        this.elapsedTime = Date.now() - this.startTime;
        const h=Math.floor(this.elapsedTime/3600000),m=Math.floor((this.elapsedTime%3600000)/60000),s=Math.floor((this.elapsedTime%60000)/1000);
        this.app.elements['stopwatch'].textContent = `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
        this.animationFrameId = requestAnimationFrame(() => this.update());
      }
      stop() {
        if (!this.isRunning) return;
        this.isRunning = false; if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        const endTime = Date.now();
        const entry = this.app.normalizeTask({
          id: `${Date.now()}`,
          ...this.app.state.activeTask,
          startTime: this.startTime,
          endTime,
          duration: Math.max(1, Math.round((endTime - this.startTime) / 60000)),
          date: this.app.getDateString(new Date(this.startTime))
        });
        this.app.taskManager.addTask(entry);
        this.reset();
      }
      reset() {
        this.isRunning=false; this.startTime=null; this.elapsedTime=0; if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        this.app.state.activeTask=null; this.app.saveToStorage(CONFIG.STORAGE_KEYS.ACTIVE_TASK, null);
        this.app.elements['stopwatch'].textContent='00:00:00'; this.app.elements['start-btn'].disabled=false; this.app.elements['stop-btn'].disabled=true;
        this.app.elements['task-input'].disabled=false; this.app.elements['active-task-indicator'].style.display='none'; this.app.elements['task-input'].value='';
      }
      resumeActiveTask(activeTask) {
        if (!activeTask?.startTime) return;
        this.startTime = activeTask.startTime; this.isRunning = true; this.app.state.activeTask = activeTask;
        this.app.elements['start-btn'].disabled = true; this.app.elements['stop-btn'].disabled = false; this.app.elements['task-input'].disabled = true;
        this.app.elements['active-task-name'].textContent = `${activeTask.category || 'Productive Work'} â€¢ ${activeTask.subcategory || 'General'}`;
        this.app.elements['active-task-start'].textContent = this.app.formatTime(activeTask.startTime); this.app.elements['active-task-indicator'].style.display = 'block';
        this.update();
      }
    }
    class TaskManager {
      constructor(app) { this.app = app; }
      initialize() { this.updateStats(); this.renderTasks(); this.renderFavorites(); }
      mergeTasks(incoming) {
        const map = new Map(this.app.state.tasks.map(t => [t.id, t]));
        incoming.forEach(t => map.set(t.id, this.app.normalizeTask(t)));
        this.app.state.tasks = [...map.values()].sort((a,b) => a.startTime - b.startTime);
        this.app.saveToStorage(CONFIG.STORAGE_KEYS.TASKS, this.app.state.tasks);
        this.updateStats(); this.renderTasks(); this.app.graphManager.updateCharts(); this.app.updateStreak();
      }
      addTask(task) {
        this.app.state.tasks.push(this.app.normalizeTask(task));
        this.app.saveToStorage(CONFIG.STORAGE_KEYS.TASKS, this.app.state.tasks);
        this.app.syncManager.queue({ type: 'upsert', entry: task, ts: Date.now() });
        this.app.syncManager.flushQueue();
        this.updateStats(); this.renderTasks(); this.app.graphManager.updateCharts(); this.app.updateStreak(true);
      }
      deleteTask(taskId) {
        this.app.state.tasks = this.app.state.tasks.filter(task => task.id !== taskId);
        this.app.saveToStorage(CONFIG.STORAGE_KEYS.TASKS, this.app.state.tasks);
        this.app.syncManager.queue({ type: 'delete', id: taskId, ts: Date.now() });
        this.updateStats(); this.renderTasks(); this.app.graphManager.updateCharts(); this.app.updateStreak();
      }
      updateStats() {
        const today = this.app.getDateString();
        const todayTasks = this.app.state.tasks.filter(task => task.date === today);
        const productiveTime = todayTasks.filter(task => this.app.isProductiveCategory(task.category)).reduce((t, task) => t + task.duration, 0);
        const sleepTime = todayTasks.filter(task => task.category === 'Sleep').reduce((t, task) => t + task.duration, 0);
        const totalTime = todayTasks.reduce((t, task) => t + task.duration, 0);
        this.app.elements['productive-time'].textContent = this.app.formatDuration(productiveTime);
        this.app.elements['sleep-time'].textContent = this.app.formatDuration(sleepTime);
        this.app.elements['total-time'].textContent = this.app.formatDuration(totalTime);

        if (this.app.shadowEngine) this.app.shadowEngine.refresh();
      }
      renderTasks() {
        const today = this.app.getDateString();
        const tasks = this.app.state.tasks.filter(task => task.date === today).sort((a,b) => b.startTime-a.startTime);
        const c = this.app.elements['tasks-list']; c.innerHTML = '';
        if (!tasks.length) {
          c.innerHTML = `<div style="text-align: center; padding: 3rem; color: var(--text-secondary);"><i class="fas fa-clipboard-list" style="font-size: 3rem; margin-bottom: 1rem;"></i><p>No tasks recorded today</p><p style="font-size: 0.9rem;">Start tracking your first task</p></div>`;
          return;
        }
        tasks.forEach(task => {
          const el=document.createElement('div');
          const isSleep = task.category === 'Sleep';
          el.className = `task-card ${isSleep ? 'sleep' : 'productive'}`;
          el.innerHTML = `<div class="task-header"><div class="task-name">${isSleep ? 'ðŸ’¤' : 'âš¡'} ${task.category} â€¢ ${task.subcategory}</div><div class="task-duration">${this.app.formatDuration(task.duration)}</div></div><div class="task-time">${this.app.formatTime(task.startTime)} - ${this.app.formatTime(task.endTime)}</div><div class="task-time">${task.description || ''}</div><div class="task-actions"><button class="btn delete-task-btn" data-id="${task.id}"><i class="fas fa-trash"></i> Delete</button></div>`;
          c.appendChild(el);
        });
        document.querySelectorAll('.delete-task-btn').forEach(btn => btn.addEventListener('click', e => this.deleteTask(e.currentTarget.getAttribute('data-id'))));
      }
      renderFavorites() {
        const container = this.app.elements['favorites-grid']; container.innerHTML='';
        if (!this.app.state.favorites.length) {
          container.innerHTML = `<div style="grid-column: 1 / -1; text-align: center; padding: 2rem; color: var(--text-secondary);"><i class="far fa-star" style="font-size: 2rem; margin-bottom: 0.5rem;"></i><p>No favorites yet</p><p style="font-size: 0.9rem;">Add tasks to favorites for quick start</p></div>`;
          return;
        }
        this.app.state.favorites.forEach((f, idx) => {
          const fav = typeof f === 'string' ? { label: f, category: 'Productive Work', subcategory: 'Execution' } : f;
          const el = document.createElement('div'); el.className='favorite-card';
          el.innerHTML = `<div class="favorite-name">${fav.label}</div><div class="favorite-actions"><button class="btn start-favorite-btn" data-index="${idx}"><i class="fas fa-play"></i></button><button class="btn remove-favorite-btn" data-index="${idx}"><i class="fas fa-times"></i></button></div>`;
          container.appendChild(el);
        });
        document.querySelectorAll('.start-favorite-btn').forEach(btn => btn.addEventListener('click', e => {
          const fav = this.app.state.favorites[parseInt(e.currentTarget.getAttribute('data-index'), 10)];
          const f = typeof fav === 'string' ? { label: fav, category: 'Productive Work', subcategory: 'Execution' } : fav;
          this.app.stopwatch.start(f.label, { category: f.category, subcategory: f.subcategory, description: f.label });
        }));
        document.querySelectorAll('.remove-favorite-btn').forEach(btn => btn.addEventListener('click', e => this.removeFavorite(parseInt(e.currentTarget.getAttribute('data-index'), 10))));
      }
      addFavorite() {
        const label = this.app.elements['task-input'].value.trim();
        if (!label) return alert('Please enter a task name to add to favorites');
        const category = this.app.resolveCategory(prompt('Favorite category', 'Productive Work'));
        const subcategory = prompt('Favorite subcategory', CATEGORY_DEFINITIONS[category]?.[0] || 'General') || 'General';
        const fav = { label, category, subcategory };
        this.app.state.favorites.push(fav);
        this.app.saveToStorage(CONFIG.STORAGE_KEYS.FAVORITES, this.app.state.favorites);
        this.renderFavorites();
      }
      removeFavorite(index) { this.app.state.favorites.splice(index,1); this.app.saveToStorage(CONFIG.STORAGE_KEYS.FAVORITES, this.app.state.favorites); this.renderFavorites(); }
    }
    class AnalyticsService {
      static buildMonthlyReport(tasks, year, month, thresholdMinutes = CONFIG.DAILY_PRODUCTIVITY_THRESHOLD_MINUTES) {
        const monthTasks = tasks.filter(t => { const d = new Date(t.startTime); return d.getFullYear() === year && d.getMonth() === month; });
        const prevTasks = tasks.filter(t => { const d = new Date(t.startTime); const pm = month === 0 ? 11 : month - 1; const py = month === 0 ? year - 1 : year; return d.getFullYear() === py && d.getMonth() === pm; });
        const totals = Object.fromEntries(Object.keys(CATEGORY_DEFINITIONS).map(c => [c, 0]));
        const daily = {};
        monthTasks.forEach(t => {
          totals[t.category] = (totals[t.category] || 0) + t.duration;
          if (!daily[t.date]) daily[t.date] = { productive: 0, sleep: 0, waste: 0, total: 0 };
          if (PRODUCTIVE_CATEGORIES.has(t.category)) daily[t.date].productive += t.duration;
          if (t.category === 'Sleep') daily[t.date].sleep += t.duration;
          if (t.category === 'Time Waste / Distraction') daily[t.date].waste += t.duration;
          daily[t.date].total += t.duration;
        });
        const totalMinutes = Object.values(totals).reduce((a,b) => a+b, 0);
        const productiveMinutes = Object.entries(totals).filter(([k]) => PRODUCTIVE_CATEGORIES.has(k)).reduce((a,[,v]) => a+v,0);
        const sleepMinutes = totals['Sleep'] || 0;
        const wasteMinutes = totals['Time Waste / Distraction'] || 0;
        const awakeMinutes = Math.max(0, totalMinutes - sleepMinutes);
        const activeDays = Math.max(1, Object.keys(daily).length);
        const productivityRatio = awakeMinutes ? productiveMinutes / awakeMinutes : 0;
        const pctByCategory = Object.fromEntries(Object.keys(totals).map(k => [k, totalMinutes ? (totals[k] / totalMinutes * 100) : 0]));
        const bestProductiveDay = Object.entries(daily).sort((a,b) => b[1].productive - a[1].productive)[0] || null;
        const worstWasteDay = Object.entries(daily).sort((a,b) => b[1].waste - a[1].waste)[0] || null;
        const sleepStreak = AnalyticsService.longestSleepConsistencyStreak(daily, 420);
        const underProductiveDays = Object.entries(daily).filter(([,v]) => v.productive < thresholdMinutes).length;
        const prevProductive = prevTasks.filter(t => PRODUCTIVE_CATEGORIES.has(t.category)).reduce((a,t)=>a+t.duration,0);
        const prevWaste = prevTasks.filter(t => t.category === 'Time Waste / Distraction').reduce((a,t)=>a+t.duration,0);
        const productiveBreakdown = AnalyticsService.breakdown(monthTasks, 'Productive Work');
        const trainingBreakdown = AnalyticsService.breakdown(monthTasks, 'Physical Training');
        return {
          year, month,
          totals,
          totalMinutes,
          productiveMinutes,
          sleepMinutes,
          wasteMinutes,
          awakeMinutes,
          pctByCategory,
          dailyAverageSleep: sleepMinutes / activeDays,
          dailyAverageProductive: productiveMinutes / activeDays,
          productivityRatio,
          daily,
          productiveBreakdown,
          trainingBreakdown,
          bestProductiveDay,
          worstWasteDay,
          sleepConsistency: { longestStreakDays: sleepStreak },
          alerts: { underProductivity: productiveMinutes < thresholdMinutes * activeDays, underProductiveDays, thresholdMinutes },
          improvement: {
            productiveDeltaMinutes: productiveMinutes - prevProductive,
            wasteDeltaMinutes: wasteMinutes - prevWaste
          }
        };
      }
      static breakdown(tasks, category) {
        const out = {};
        tasks.filter(t => t.category === category).forEach(t => out[t.subcategory] = (out[t.subcategory] || 0) + t.duration);
        return out;
      }
      static longestSleepConsistencyStreak(daily, targetMin) {
        const days = Object.keys(daily).sort();
        let best = 0; let run = 0;
        days.forEach(d => {
          if ((daily[d].sleep || 0) >= targetMin) { run += 1; best = Math.max(best, run); }
          else run = 0;
        });
        return best;
      }
    }
    class UIManager {
      constructor(app) { this.app = app; this.currentMotivationIndex = 0; }
      initialize() { this.updateDateTime(); this.startMotivationRotation(); }
      updateDateTime() {
        const updateTime = () => {
          const now = new Date();
          this.app.elements['current-date'].textContent = now.toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
          this.app.elements['current-time'].textContent = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        }; updateTime(); setInterval(updateTime, 1000);
      }
      startMotivationRotation() { this.updateMotivation(); setInterval(() => this.updateMotivation(), CONFIG.MOTIVATION_INTERVAL); }
      updateMotivation() {
        const e = this.app.elements['motivation-line']; e.style.opacity = '0';
        setTimeout(() => { let n; do { n = Math.floor(Math.random() * MOTIVATION_LINES.length); } while (n === this.currentMotivationIndex && MOTIVATION_LINES.length > 1); this.currentMotivationIndex = n; e.textContent = MOTIVATION_LINES[n]; e.style.opacity = '1'; }, 500);
      }
      showStreakPopup() {
        const streak = this.app.state.streak; this.app.elements['streak-count'].textContent = streak;
        this.app.elements['streak-message'].textContent = STREAK_MESSAGES[streak] || `${streak} days strong. Keep going.`;
        this.app.elements['streak-popup'].style.display = 'flex';
      }
      hideStreakPopup() { this.app.elements['streak-popup'].style.display = 'none'; }
      showReport() {
        const now = new Date();
        const r = AnalyticsService.buildMonthlyReport(this.app.state.tasks, now.getFullYear(), now.getMonth());
        const monthName = now.toLocaleString('default', { month: 'long' });
        const rows = Object.keys(r.daily).sort().map(date => {
          const d = r.daily[date];
          return `<tr><td style="padding:0.75rem;border-bottom:1px solid var(--border);">${new Date(date).toLocaleDateString('en-US',{month:'short',day:'numeric',weekday:'short'})}</td><td style="padding:0.75rem;border-bottom:1px solid var(--border);">${this.app.formatDuration(d.productive)}</td><td style="padding:0.75rem;border-bottom:1px solid var(--border);">${this.app.formatDuration(d.sleep)}</td><td style="padding:0.75rem;border-bottom:1px solid var(--border);">${this.app.formatDuration(d.waste)}</td><td style="padding:0.75rem;border-bottom:1px solid var(--border);">${this.app.formatDuration(d.total)}</td></tr>`;
        }).join('');
        const catLines = Object.entries(r.totals).map(([k,v]) => `<li>${k}: ${this.app.formatDuration(v)} (${r.pctByCategory[k].toFixed(1)}%)</li>`).join('');
        const prodBreak = Object.entries(r.productiveBreakdown).map(([k,v]) => `<li>${k}: ${this.app.formatDuration(v)}</li>`).join('') || '<li>No entries</li>';
        const trainBreak = Object.entries(r.trainingBreakdown).map(([k,v]) => `<li>${k}: ${this.app.formatDuration(v)}</li>`).join('') || '<li>No entries</li>';
        const best = r.bestProductiveDay ? `${r.bestProductiveDay[0]} (${this.app.formatDuration(r.bestProductiveDay[1].productive)})` : 'N/A';
        const worst = r.worstWasteDay ? `${r.worstWasteDay[0]} (${this.app.formatDuration(r.worstWasteDay[1].waste)})` : 'N/A';
        this.app.elements['report-content'].innerHTML = `
          <h3 style="margin-bottom:1rem;">${monthName} ${r.year} Monthly Report</h3>
          <p><strong>Total sleep:</strong> ${this.app.formatDuration(r.sleepMinutes)} | <strong>Total productive:</strong> ${this.app.formatDuration(r.productiveMinutes)} | <strong>Total waste:</strong> ${this.app.formatDuration(r.wasteMinutes)}</p>
          <p><strong>Total awake:</strong> ${this.app.formatDuration(r.awakeMinutes)} | <strong>Productivity ratio:</strong> ${(r.productivityRatio*100).toFixed(1)}%</p>
          <p><strong>Daily avg sleep:</strong> ${this.app.formatDuration(r.dailyAverageSleep)} | <strong>Daily avg productive:</strong> ${this.app.formatDuration(r.dailyAverageProductive)}</p>
          <p><strong>Improvement vs previous month:</strong> Productive ${this.app.formatDuration(r.improvement.productiveDeltaMinutes)} | Waste ${this.app.formatDuration(r.improvement.wasteDeltaMinutes)}</p>
          <p><strong>Best productive day:</strong> ${best} | <strong>Worst waste day:</strong> ${worst}</p>
          <p><strong>Sleep consistency:</strong> longest >=7h streak is ${r.sleepConsistency.longestStreakDays} days</p>
          <p><strong>Alerts:</strong> ${r.alerts.underProductivity ? `Under productivity (${r.alerts.underProductiveDays} days below ${this.app.formatDuration(r.alerts.thresholdMinutes)})` : 'None'}</p>
          <h4 style="margin-top:1rem;">Category Totals</h4><ul>${catLines}</ul>
          <h4>Productive Work Breakdown</h4><ul>${prodBreak}</ul>
          <h4>Physical Training Breakdown</h4><ul>${trainBreak}</ul>
          <h4>Daily Breakdown</h4>
          <div style="overflow-x:auto;"><table style="width:100%;border-collapse:collapse;"><thead><tr style="background: rgba(30, 30, 30, 0.8);"><th style="padding:0.75rem;text-align:left;border-bottom:1px solid var(--border);">Date</th><th style="padding:0.75rem;text-align:left;border-bottom:1px solid var(--border);">Productive</th><th style="padding:0.75rem;text-align:left;border-bottom:1px solid var(--border);">Sleep</th><th style="padding:0.75rem;text-align:left;border-bottom:1px solid var(--border);">Waste</th><th style="padding:0.75rem;text-align:left;border-bottom:1px solid var(--border);">Total</th></tr></thead><tbody>${rows}</tbody></table></div>`;
        this.app.elements['report-modal'].style.display = 'flex';
      }
      hideReport() { this.app.elements['report-modal'].style.display = 'none'; }
      exportData() {
        const now = new Date();
        const report = AnalyticsService.buildMonthlyReport(this.app.state.tasks, now.getFullYear(), now.getMonth());
        const csvContent = [
          ['Date','Category','Subcategory','Start Time','End Time','Duration (minutes)','Description'].join(','),
          ...this.app.state.tasks.map(task => [task.date,`"${task.category}"`,`"${task.subcategory}"`,new Date(task.startTime).toLocaleString(),new Date(task.endTime).toLocaleString(),task.duration,`"${(task.description || '').replace(/"/g,'""')}"`].join(','))
        ].join('\n');
        const csvBlob = new Blob([csvContent], { type: 'text/csv' });
        const jsonBlob = new Blob([JSON.stringify({ schemaVersion: CONFIG.DB_SCHEMA_VERSION, exportedAt: new Date().toISOString(), entries: this.app.state.tasks, monthlyReport: report }, null, 2)], { type: 'application/json' });
        [['csv', csvBlob], ['json', jsonBlob]].forEach(([ext, blob]) => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url; a.download = `discipline-data-${this.app.getDateString()}.${ext}`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        });
      }
    }

    class ShadowEngine {
      constructor(app) {
        this.app = app;
        this.shadowSevenDayAverage = 0;
        this.rankTiers = [
          { min: 0, title: 'Recruit', badge: 'Builder' },
          { min: 120, title: 'Builder', badge: 'Operator' },
          { min: 180, title: 'Operator', badge: 'Executor' },
          { min: 240, title: 'Executor', badge: 'Vanguard' },
          { min: 300, title: 'Vanguard', badge: 'Elite' },
          { min: 360, title: 'Elite', badge: 'Apex' },
          { min: 420, title: 'Apex', badge: 'Mythic' }
        ];
      }

      initialize() {
        const stored = parseFloat(this.app.loadFromStorage(CONFIG.STORAGE_KEYS.SHADOW_AVG));
        this.shadowSevenDayAverage = Number.isFinite(stored) ? stored : 0;
        this.refresh(false);
      }

      getDailyProductiveMap() {
        const dailyMap = new Map();
        this.app.state.tasks.forEach(task => {
          if (!this.app.isProductiveCategory(task.category)) return;
          dailyMap.set(task.date, (dailyMap.get(task.date) || 0) + task.duration);
        });
        return dailyMap;
      }

      buildDailyProductiveSeries() {
        const dailyMap = this.getDailyProductiveMap();
        if (dailyMap.size === 0) return [];

        const sorted = [...dailyMap.keys()].sort();
        const start = new Date(sorted[0]);
        const end = new Date(this.app.getDateString());
        const series = [];

        for (let cursor = new Date(start); cursor <= end; cursor.setDate(cursor.getDate() + 1)) {
          const key = this.app.getDateString(cursor);
          series.push(dailyMap.get(key) || 0);
        }
        return series;
      }

      computeRollingMetrics() {
        const series = this.buildDailyProductiveSeries();
        if (!series.length) return { bestAvg: 0, currentAvg: 0, previousAvg: 0, todayMinutes: 0 };

        const prefix = new Array(series.length + 1).fill(0);
        for (let i = 0; i < series.length; i++) prefix[i + 1] = prefix[i] + series[i];

        let bestAvg = 0;
        if (series.length < 7) {
          bestAvg = prefix[series.length] / 7;
        } else {
          for (let i = 7; i <= series.length; i++) {
            const avg = (prefix[i] - prefix[i - 7]) / 7;
            if (avg > bestAvg) bestAvg = avg;
          }
        }

        const endIdx = series.length;
        const currentAvg = (prefix[endIdx] - prefix[Math.max(0, endIdx - 7)]) / 7;
        const previousAvg = endIdx >= 14
          ? (prefix[endIdx - 7] - prefix[endIdx - 14]) / 7
          : 0;

        return {
          bestAvg,
          currentAvg,
          previousAvg,
          todayMinutes: series[series.length - 1] || 0
        };
      }

      getShadowRank(minutes) {
        let selected = this.rankTiers[0];
        for (const tier of this.rankTiers) {
          if (minutes >= tier.min) selected = tier;
        }
        return selected;
      }

      getCurrentStatus(percentage) {
        if (percentage >= 100) return 'Dominating the Shadow';
        if (percentage >= 90) return 'Near the Shadow';
        if (percentage >= 70) return 'Drifting from Standard';
        return 'Below Identity';
      }

      getProgressStyle(percentage) {
        if (percentage >= 100) return { color: '#28a745', shadow: '0 0 12px rgba(40,167,69,0.45)' };
        if (percentage >= 90) return { color: '#007bff', shadow: 'none' };
        if (percentage >= 70) return { color: '#ffc107', shadow: 'none' };
        return { color: '#dc3545', shadow: 'none' };
      }

      getMomentum(currentAvg, previousAvg) {
        const delta = currentAvg - previousAvg;
        if (delta > 8) return { label: `Rising (+${this.app.formatDuration(delta)})`, cls: 'shadow-momentum-positive' };
        if (delta < -8) return { label: `Drifting (-${this.app.formatDuration(Math.abs(delta))})`, cls: 'shadow-momentum-negative' };
        return { label: 'Stable', cls: 'shadow-momentum-flat' };
      }

      render({ todayMinutes, shadowAvg, currentAvg, previousAvg, isNewStandard }) {
        const safeShadow = shadowAvg > 0 ? shadowAvg : 1;
        const gap = shadowAvg - todayMinutes;
        const percentage = (todayMinutes / safeShadow) * 100;

        this.app.elements['shadow-current-minutes'].textContent = this.app.formatDuration(todayMinutes);
        this.app.elements['shadow-average'].textContent = this.app.formatDuration(shadowAvg);
        this.app.elements['shadow-weekly-average'].textContent = this.app.formatDuration(currentAvg);

        const momentum = this.getMomentum(currentAvg, previousAvg);
        const momentumEl = this.app.elements['shadow-momentum'];
        momentumEl.textContent = momentum.label;
        momentumEl.className = momentum.cls;

        this.app.elements['shadow-percent'].textContent = `${percentage.toFixed(1)}%`;
        const gapEl = this.app.elements['shadow-gap'];
        const absGap = Math.abs(gap);
        gapEl.textContent = `${gap >= 0 ? '-' : '+'}${this.app.formatDuration(absGap)}`;
        gapEl.className = gap > 0 ? 'shadow-gap-positive' : (gap < 0 ? 'shadow-gap-negative' : 'shadow-gap-equal');

        this.app.elements['shadow-status'].textContent = this.getCurrentStatus(percentage);
        const rank = this.getShadowRank(shadowAvg);
        this.app.elements['shadow-rank'].textContent = `Rank: ${rank.title}`;
        this.app.elements['shadow-badge'].textContent = rank.badge;
        this.app.elements['shadow-note'].textContent = 'Calculated from real historical data only';

        const fill = this.app.elements['shadow-progress-fill'];
        const cappedWidth = Math.min(130, Math.max(0, percentage));
        const style = this.getProgressStyle(percentage);
        fill.style.width = `${cappedWidth}%`;
        fill.style.background = style.color;
        fill.style.boxShadow = style.shadow;

        if (isNewStandard) {
          const card = this.app.elements['shadow-standard-card'];
          card.classList.remove('shadow-new-standard');
          void card.offsetWidth;
          card.classList.add('shadow-new-standard');
        }
      }

      refresh(allowAnimation = true) {
        const metrics = this.computeRollingMetrics();
        const historicalBest = metrics.bestAvg;
        const resolvedShadow = Math.max(this.shadowSevenDayAverage, historicalBest);
        const isNewStandard = resolvedShadow > this.shadowSevenDayAverage;

        if (resolvedShadow !== this.shadowSevenDayAverage) {
          this.shadowSevenDayAverage = resolvedShadow;
          this.app.saveToStorage(CONFIG.STORAGE_KEYS.SHADOW_AVG, resolvedShadow);
        }

        this.render({
          todayMinutes: metrics.todayMinutes,
          shadowAvg: resolvedShadow,
          currentAvg: metrics.currentAvg,
          previousAvg: metrics.previousAvg,
          isNewStandard: allowAnimation && isNewStandard
        });
      }
    }

    class GraphManager {
      constructor(app) { this.app = app; this.charts = { productivity: null, sleep: null }; this.totalCounterAnimation = null; this.lastFilteredTotalMinutes = 0; }
      initialize() { if (!window.Chart) return; this.createCharts(); this.setupChartControls(); this.lastFilteredTotalMinutes = this.getCurrentFilteredTotalMinutes(); this.animateFilteredTotal(0, this.lastFilteredTotalMinutes); }

      getCurrentFilter() {
        return this.app.elements['prod-filter']?.value || 'all';
      }

      passesProductivityFilter(task, filter) {
        if (task.category === 'Sleep') return false;
        const tag = task.graph_tag || 'neutral';
        const waste = task.waste_level || 'NONE';
        if (filter === 'all') return true;
        if (filter === 'productivity') return tag === 'productivity';
        if (filter === 'distraction') return tag === 'distraction';
        if (filter === 'neutral') return tag === 'neutral';
        if (filter === 'high_waste') return waste === 'HIGH';
        return true;
      }

      getColorScheme(filter) {
        if (filter === 'productivity') return { border: 'rgb(40, 180, 99)', fill: 'rgba(40, 180, 99, 0.16)' };
        if (filter === 'distraction' || filter === 'high_waste') return { border: 'rgb(220, 53, 69)', fill: 'rgba(220, 53, 69, 0.16)' };
        if (filter === 'neutral') return { border: 'rgb(148, 163, 184)', fill: 'rgba(148, 163, 184, 0.14)' };
        return { border: 'rgb(0,123,255)', fill: 'rgba(0,123,255,0.12)' };
      }

      createCharts() {
        const prodCtx = this.app.elements['productivity-chart'].getContext('2d');
        this.charts.productivity = new Chart(prodCtx, {
          type: 'line',
          data: this.getProductivityData('7d', this.getCurrentFilter()),
          options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: { duration: 420, easing: 'easeOutCubic' },
            transitions: {
              active: { animation: { duration: 320 } },
              resize: { animation: { duration: 320 } }
            },
            plugins: { legend: { display: false } },
            scales: { y: { beginAtZero: true, ticks: { callback: v => v + 'h' } } },
            elements: {
              point: {
                radius: 0,
                hoverRadius: 0,
                pointStyle: 'circle',
                hoverBorderWidth: 2
              },
              line: { tension: 0.34, borderWidth: 2.5 }
            }
          }
        });

        const sleepCtx = this.app.elements['sleep-chart'].getContext('2d');
        this.charts.sleep = new Chart(sleepCtx, {
          type: 'bar',
          data: this.getSleepData('7d'),
          options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: { duration: 380, easing: 'easeOutQuad' },
            plugins: { legend: { display: false } },
            scales: { y: { beginAtZero: true, max: 12, ticks: { callback: v => v + 'h' } } }
          }
        });
      }

      getProductivityData(range='7d', filter='all') {
        const days = CONFIG.CHART_RANGES[range] || 7, data=[], labels=[], today=new Date();
        for (let i=days-1;i>=0;i--) {
          const d=new Date(today);
          d.setDate(today.getDate()-i);
          const ds=this.app.getDateString(d);
          const mins=this.app.state.tasks
            .filter(t => t.date===ds && this.passesProductivityFilter(t, filter))
            .reduce((a,t)=>a+t.duration,0);
          labels.push(d.toLocaleDateString('en-US',{month:'short',day:'numeric'}));
          data.push(parseFloat((mins/60).toFixed(2)));
        }
        const colors = this.getColorScheme(filter);
        return {
          labels,
          datasets: [{
            label:'Tracked Hours',
            data,
            borderColor: colors.border,
            backgroundColor: colors.fill,
            pointBackgroundColor: colors.border,
            pointBorderColor: 'rgba(255,255,255,0.65)',
            pointHoverBackgroundColor: '#ffffff',
            pointHoverBorderColor: colors.border,
            fill:true
          }]
        };
      }

      getSleepData(range='7d') {
        const days = CONFIG.CHART_RANGES[range] || 7, data=[], labels=[], today=new Date();
        for (let i=days-1;i>=0;i--) { const d=new Date(today); d.setDate(today.getDate()-i); const ds=this.app.getDateString(d); const mins=this.app.state.tasks.filter(t => t.date===ds && t.category==='Sleep').reduce((a,t)=>a+t.duration,0); labels.push(d.toLocaleDateString('en-US',{month:'short',day:'numeric'})); data.push(parseFloat((mins/60).toFixed(1))); }
        return { labels, datasets: [{ label:'Sleep Hours', data, backgroundColor:'rgba(111, 66, 193, 0.7)', borderColor:'rgb(111,66,193)', borderWidth:1, borderRadius:4 }] };
      }

      getCurrentFilteredTotalMinutes() {
        const filter = this.getCurrentFilter();
        const range = this.app.elements['prod-range'].value;
        const days = CONFIG.CHART_RANGES[range] || 7;
        const start = new Date();
        start.setDate(start.getDate() - (days - 1));
        const startDate = this.app.getDateString(start);
        return this.app.state.tasks
          .filter(t => t.date >= startDate && this.passesProductivityFilter(t, filter))
          .reduce((sum, t) => sum + t.duration, 0);
      }

      animateFilteredTotal(fromMinutes, toMinutes) {
        if (!this.app.elements['prod-filter-total']) return;
        const el = this.app.elements['prod-filter-total'];
        const start = performance.now();
        const duration = 450;
        const tick = (now) => {
          const progress = Math.min(1, (now - start) / duration);
          const eased = 1 - Math.pow(1 - progress, 3);
          const current = fromMinutes + (toMinutes - fromMinutes) * eased;
          el.textContent = this.app.formatDuration(current);
          if (progress < 1) this.totalCounterAnimation = requestAnimationFrame(tick);
        };
        if (this.totalCounterAnimation) cancelAnimationFrame(this.totalCounterAnimation);
        this.totalCounterAnimation = requestAnimationFrame(tick);
      }

      updateCharts() {
        if (!this.charts.productivity || !this.charts.sleep) return;
        const prodRange = this.app.elements['prod-range'].value;
        const sleepRange = this.app.elements['sleep-range'].value;
        const filter = this.getCurrentFilter();

        const prodContainer = this.app.elements['productivity-chart'].closest('.graph-canvas-container');
        if (prodContainer) prodContainer.classList.add('filter-updating');

        const fromMinutes = this.lastFilteredTotalMinutes;
        this.charts.productivity.data=this.getProductivityData(prodRange, filter);
        this.charts.sleep.data=this.getSleepData(sleepRange);
        this.charts.productivity.update();
        this.charts.sleep.update();

        const toMinutes = this.getCurrentFilteredTotalMinutes();
        this.lastFilteredTotalMinutes = toMinutes;
        this.animateFilteredTotal(fromMinutes, toMinutes);
        setTimeout(() => { if (prodContainer) prodContainer.classList.remove('filter-updating'); }, 360);
      }

      setupChartControls() {
        this.app.elements['prod-range'].addEventListener('change', () => this.updateCharts());
        this.app.elements['prod-filter'].addEventListener('change', () => this.updateCharts());
        this.app.elements['sleep-range'].addEventListener('change', () => this.updateCharts());
      }
    }
    class EventManager {
      constructor(app) { this.app = app; }
      initialize() { this.bindEvents(); }
      bindEvents() {
        this.app.elements['start-btn'].addEventListener('click', () => this.app.stopwatch.start());
        this.app.elements['stop-btn'].addEventListener('click', () => this.app.stopwatch.stop());
        this.app.elements['sleep-btn'].addEventListener('click', () => this.app.stopwatch.startSleep());
        this.app.elements['add-favorite'].addEventListener('click', () => this.app.taskManager.addFavorite());
        this.app.elements['task-input'].addEventListener('keypress', e => { if (e.key === 'Enter' && !this.app.stopwatch.isRunning) this.app.stopwatch.start(); });
        this.app.elements['view-report'].addEventListener('click', () => this.app.uiManager.showReport());
        this.app.elements['export-data'].addEventListener('click', () => this.app.uiManager.exportData());
        this.app.elements['close-modal'].addEventListener('click', () => this.app.uiManager.hideReport());
        this.app.elements['close-report'].addEventListener('click', () => this.app.uiManager.hideReport());
        this.app.elements['print-report'].addEventListener('click', () => window.print());
        this.app.elements['close-streak'].addEventListener('click', () => this.app.uiManager.hideStreakPopup());
        this.app.elements['report-modal'].addEventListener('click', e => { if (e.target === this.app.elements['report-modal']) this.app.uiManager.hideReport(); });
      }
    }
    window.classifyActivity = (userInput) => ActivityClassifier.classify(userInput);
    window.app = new DisciplineTracker();
    document.addEventListener('DOMContentLoaded', () => window.app.initialize());
    document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'visible' && window.app.taskManager) { window.app.taskManager.updateStats(); window.app.taskManager.renderTasks(); window.app.taskManager.renderFavorites(); if (window.app.shadowEngine) window.app.shadowEngine.refresh(false); } });
    window.addEventListener('beforeunload', () => { if (window.app?.stopwatch?.animationFrameId) cancelAnimationFrame(window.app.stopwatch.animationFrameId); });
  </script>
</body>
</html>
