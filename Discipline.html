<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Discipline Tracker Pro</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <style>
    :root {
      --bg-dark: #0a0a0a;
      --bg-darker: #080808;
      --card-bg: #1a1a1a;
      --border: #2a2a2a;
      --text-primary: #f5f5f7;
      --text-secondary: #a0a0a8;
      --text-accent: #ffffff;
      --success: #28a745;
      --warning: #ffc107;
      --danger: #dc3545;
      --primary: #007bff;
      --info: #17a2b8;
      --purple: #6f42c1;
      --yellow: #ffcc00;
      --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      --shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
      --shadow-hover: 0 12px 40px rgba(0, 0, 0, 0.4);
    }
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    }
    body {
      background: linear-gradient(135deg, #121212 0%, #0d0d0d 100%);
      color: var(--text-primary);
      min-height: 100vh;
      padding: 20px;
      line-height: 1.6;
      overflow-x: hidden;
    }
    .app-container {
      max-width: 1400px;
      margin: 0 auto;
      position: relative;
    }
    /* Header */
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1.5rem;
      margin-bottom: 2rem;
      background: rgba(25, 25, 25, 0.95);
      border-radius: 16px;
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .app-title {
      font-size: 1.8rem;
      font-weight: 700;
      letter-spacing: -0.5px;
      display: flex;
      align-items: center;
      gap: 12px;
      color: var(--text-accent);
    }
    .app-title i {
      color: var(--primary);
    }
    .view-controls {
      display: flex;
      gap: 12px;
    }
    .btn {
      background: linear-gradient(145deg, #2a2a2a, #222);
      color: var(--text-primary);
      border: 1px solid var(--border);
      padding: 10px 20px;
      border-radius: 10px;
      cursor: pointer;
      transition: var(--transition);
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 500;
      font-size: 0.95rem;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-hover);
      border-color: #3a3a3a;
    }
    .btn-primary {
      background: linear-gradient(145deg, #0066cc, #0052a3);
      border-color: #007bff;
    }
    .btn-success {
      background: linear-gradient(145deg, #28a745, #1e7e34);
      border-color: var(--success);
    }
    .btn-warning {
      background: linear-gradient(145deg, #ffc107, #e0a800);
      border-color: var(--warning);
    }
    .btn-danger {
      background: linear-gradient(145deg, #dc3545, #c82333);
      border-color: var(--danger);
    }
    /* Motivation Container */
    .motivation-container {
      text-align: center;
      padding: 1.5rem;
      margin: 0 auto 2.5rem;
      max-width: 900px;
      font-size: 1.1rem;
      border-radius: 16px;
      background: linear-gradient(135deg, rgba(25, 25, 25, 0.9), rgba(30, 30, 30, 0.9));
      border: 1px solid var(--border);
      position: relative;
      overflow: hidden;
      box-shadow: var(--shadow);
    }
    #motivation-line {
      transition: opacity 0.5s ease;
      font-weight: 500;
      letter-spacing: 0.3px;
    }
    /* Date Display */
    .date-display {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 2rem;
      padding: 1.2rem;
      background: rgba(25, 25, 25, 0.9);
      border-radius: 16px;
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
    }
    #current-date {
      font-size: 1.4rem;
      font-weight: 600;
      color: var(--text-accent);
    }
    #current-time {
      font-family: 'Courier New', monospace;
      font-size: 1.2rem;
      font-weight: 600;
      color: var(--primary);
      background: rgba(0, 123, 255, 0.1);
      padding: 8px 16px;
      border-radius: 8px;
      border: 1px solid rgba(0, 123, 255, 0.3);
    }
    /* Main Layout */
    .main-content {
      display: grid;
      grid-template-columns: 1fr 400px;
      gap: 2rem;
      margin-bottom: 2rem;
    }
    /* Stopwatch Container */
    .stopwatch-container {
      background: linear-gradient(135deg, rgba(25, 25, 25, 0.95), rgba(30, 30, 30, 0.95));
      border-radius: 20px;
      padding: 2rem;
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
    }
    .stopwatch-display {
      font-size: 4rem;
      font-family: 'Courier New', monospace;
      font-weight: 700;
      text-align: center;
      color: var(--primary);
      margin: 1.5rem 0;
      padding: 1.5rem;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 16px;
      border: 2px solid var(--border);
      text-shadow: 0 0 20px rgba(0, 123, 255, 0.3);
      letter-spacing: 2px;
    }
    .task-input-container {
      display: flex;
      gap: 12px;
      margin: 2rem 0;
    }
    .task-input {
      flex: 1;
      padding: 1rem 1.5rem;
      font-size: 1.1rem;
      background: rgba(15, 15, 15, 0.8);
      border: 2px solid var(--border);
      border-radius: 12px;
      color: var(--text-primary);
      transition: var(--transition);
    }
    .task-input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
    }
    .controls-container {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      margin-bottom: 2rem;
    }
    .controls-container .btn {
      padding: 1rem;
      font-size: 1.1rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }
    .active-task-indicator {
      background: linear-gradient(135deg, rgba(40, 167, 69, 0.1), rgba(25, 135, 84, 0.1));
      border: 1px solid var(--success);
      border-radius: 12px;
      padding: 1.5rem;
      margin: 1.5rem 0;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.4); }
      70% { box-shadow: 0 0 0 10px rgba(40, 167, 69, 0); }
      100% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0); }
    }
    /* Favorites Section */
    .section-title {
      font-size: 1.2rem;
      font-weight: 600;
      color: var(--text-accent);
      margin: 2rem 0 1rem;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .favorites-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 10px;
      margin-bottom: 2rem;
    }
    .favorite-card {
      background: rgba(30, 30, 30, 0.8);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1rem;
      cursor: pointer;
      transition: var(--transition);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .favorite-card:hover {
      transform: translateY(-3px);
      background: rgba(40, 40, 40, 0.9);
      border-color: var(--primary);
    }
    .favorite-name {
      font-weight: 500;
    }
    .favorite-actions {
      display: flex;
      gap: 8px;
    }
    /* Today's Tasks */
    .tasks-list {
      max-height: 400px;
      overflow-y: auto;
      padding-right: 8px;
    }
    .tasks-list::-webkit-scrollbar {
      width: 6px;
    }
    .tasks-list::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 3px;
    }
    .tasks-list::-webkit-scrollbar-thumb {
      background: var(--primary);
      border-radius: 3px;
    }
    .task-card {
      background: rgba(30, 30, 30, 0.8);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1.2rem;
      margin-bottom: 10px;
      transition: var(--transition);
    }
    .task-card:hover {
      transform: translateX(5px);
      background: rgba(40, 40, 40, 0.9);
    }
    .task-card.sleep {
      border-left: 4px solid var(--purple);
    }
    .task-card.productive {
      border-left: 4px solid var(--success);
    }
    .task-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .task-name {
      font-weight: 600;
      font-size: 1.1rem;
    }
    .task-duration {
      font-family: 'Courier New', monospace;
      font-weight: 600;
      color: var(--primary);
    }
    .task-time {
      font-size: 0.9rem;
      color: var(--text-secondary);
      margin-bottom: 8px;
    }
    .task-actions {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }
    /* Stats Dashboard */
    .stats-dashboard {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 1.5rem;
      margin-bottom: 2rem;
    }
    .stat-card {
      background: linear-gradient(135deg, rgba(25, 25, 25, 0.9), rgba(30, 30, 30, 0.9));
      border-radius: 16px;
      padding: 1.5rem;
      border: 1px solid var(--border);
    }
    .stat-value {
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 8px;
    }
    .stat-label {
      font-size: 0.95rem;
      color: var(--text-secondary);
    }
    .stat-productive { color: var(--success); }
    .stat-sleep { color: var(--purple); }
    .stat-total { color: var(--primary); }
    .stat-streak { color: var(--warning); }

    /* Shadow Engine */
    .shadow-section {
      margin-bottom: 2rem;
    }
    .shadow-title {
      font-size: 1.15rem;
      font-weight: 700;
      letter-spacing: 0.8px;
      margin-bottom: 1rem;
      color: var(--text-accent);
    }
    .shadow-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 1rem;
    }
    .shadow-card {
      background: linear-gradient(145deg, rgba(18, 18, 18, 0.95), rgba(24, 24, 24, 0.95));
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 1.25rem;
      box-shadow: var(--shadow);
      transition: transform 320ms ease, box-shadow 320ms ease, border-color 320ms ease;
    }
    .shadow-card:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-hover);
      border-color: rgba(255, 255, 255, 0.12);
    }
    .shadow-card-title {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.6px;
      color: var(--text-secondary);
      margin-bottom: 0.85rem;
    }
    .shadow-main-value {
      font-size: 2rem;
      font-weight: 700;
      margin-bottom: 0.35rem;
      color: var(--text-accent);
    }
    .shadow-line {
      font-size: 0.9rem;
      color: var(--text-secondary);
      margin-bottom: 0.45rem;
    }
    .shadow-subtitle {
      margin: 0.65rem 0 0.4rem;
      font-size: 0.78rem;
      letter-spacing: 0.5px;
      text-transform: uppercase;
      color: rgba(255,255,255,0.65);
    }
    .shadow-verdict {
      margin: 0.2rem 0 0.8rem;
      padding: 0.55rem 0.7rem;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.03);
      color: var(--text-accent);
      font-size: 0.86rem;
    }
    .shadow-goal-list {
      margin-top: 0.6rem;
      display: grid;
      gap: 0.4rem;
    }
    .shadow-goal-item {
      display: flex;
      justify-content: space-between;
      gap: 0.6rem;
      font-size: 0.84rem;
      color: var(--text-secondary);
    }
    .shadow-goal-item strong {
      color: var(--text-accent);
      font-weight: 600;
    }
    .shadow-goal-done { color: var(--success) !important; }
    .shadow-gap-positive { color: var(--danger); }
    .shadow-gap-negative { color: var(--success); }
    .shadow-gap-equal { color: var(--text-secondary); }
    .shadow-momentum-positive { color: var(--success); }
    .shadow-momentum-negative { color: var(--danger); }
    .shadow-momentum-flat { color: var(--warning); }
    .shadow-pressure-low { color: var(--success); }
    .shadow-pressure-mid { color: var(--warning); }
    .shadow-pressure-high { color: var(--danger); }
    .shadow-badge {
      display: inline-flex;
      padding: 5px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.05);
      font-size: 0.8rem;
      color: var(--text-primary);
      margin-top: 0.25rem;
      margin-right: 0.5rem;
    }
    .shadow-progress {
      margin-top: 0.75rem;
      height: 8px;
      width: 100%;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }
    .shadow-progress-fill {
      width: 0%;
      height: 100%;
      border-radius: inherit;
      transition: width 420ms ease, background 420ms ease, box-shadow 420ms ease;
      background: #dc3545;
    }
    .shadow-duel-bar {
      margin-top: 0.6rem;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      height: 8px;
    }
    .shadow-duel-you,
    .shadow-duel-shadow {
      border-radius: 999px;
      background: rgba(255,255,255,0.08);
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.06);
    }
    .shadow-duel-you-fill,
    .shadow-duel-shadow-fill {
      height: 100%;
      width: 0%;
      transition: width 420ms ease;
    }
    .shadow-duel-you-fill { background: rgba(40, 167, 69, 0.9); }
    .shadow-duel-shadow-fill { background: rgba(220, 53, 69, 0.9); }
    .shadow-new-standard {
      animation: shadowPulse 520ms ease;
    }
    @keyframes shadowPulse {
      0% { box-shadow: var(--shadow); border-color: var(--border); }
      50% { box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.25), var(--shadow-hover); border-color: rgba(40, 167, 69, 0.7); }
      100% { box-shadow: var(--shadow); border-color: var(--border); }
    }
    /* Graphs Container */
    .graphs-container {
      display: flex;
      flex-direction: column;
      gap: 2rem;
    }
    .graph-card {
      background: linear-gradient(160deg, rgba(22, 24, 30, 0.95), rgba(17, 18, 22, 0.96));
      border-radius: 20px;
      padding: 1.5rem;
      border: 1px solid rgba(255, 255, 255, 0.06);
      box-shadow: 0 14px 36px rgba(0, 0, 0, 0.35);
      animation: graphFadeIn 400ms ease, graphSlideUp 500ms ease;
      transition: transform 350ms ease, box-shadow 350ms ease, border-color 350ms ease;
      will-change: transform, box-shadow;
    }
    .graph-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 18px 44px rgba(0, 0, 0, 0.42);
      border-color: rgba(0, 123, 255, 0.25);
    }
    .graph-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      gap: 10px;
      flex-wrap: wrap;
    }
    .graph-title {
      font-size: 1.2rem;
      font-weight: 600;
      color: var(--text-accent);
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .graph-controls {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    .range-select {
      background: rgba(12, 12, 15, 0.9);
      color: var(--text-primary);
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 8px 12px;
      border-radius: 10px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: border-color 300ms ease, box-shadow 300ms ease, transform 300ms ease;
    }
    .range-select:hover {
      border-color: rgba(0, 123, 255, 0.35);
      transform: translateY(-1px);
    }
    .range-select:focus {
      outline: none;
      border-color: rgba(0, 123, 255, 0.65);
      box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.12);
    }
    .graph-canvas-container {
      position: relative;
      height: 250px;
      width: 100%;
      transition: opacity 350ms ease, transform 350ms ease;
    }
    .graph-canvas-container.filter-updating {
      opacity: 0.55;
      transform: translateY(4px);
    }
    .prod-total-counter {
      min-width: 100px;
      text-align: right;
      font-weight: 600;
      color: #98f5a7;
      font-family: 'Courier New', monospace;
      letter-spacing: 0.3px;
    }
    @keyframes graphFadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    @keyframes graphSlideUp {
      from { transform: translateY(10px); }
      to { transform: translateY(0); }
    }
    /* Streak Popup */
    .streak-popup-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      backdrop-filter: blur(5px);
    }
    .streak-popup {
      background: linear-gradient(135deg, #1a1a1a, #222);
      border-radius: 24px;
      padding: 3rem;
      max-width: 500px;
      width: 90%;
      text-align: center;
      border: 1px solid var(--border);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      animation: popupAppear 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    @keyframes popupAppear {
      from { transform: scale(0.8); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }
    .streak-icon {
      font-size: 4rem;
      color: var(--warning);
      margin-bottom: 1.5rem;
    }
    .streak-count {
      font-size: 5rem;
      font-weight: 800;
      color: var(--warning);
      margin: 1rem 0;
      text-shadow: 0 0 30px rgba(255, 204, 0, 0.3);
    }
    .streak-message {
      font-size: 1.2rem;
      color: var(--text-primary);
      margin: 1.5rem 0;
      line-height: 1.6;
    }
    /* Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      padding: 20px;
    }
    .modal {
      background: linear-gradient(135deg, #1a1a1a, #222);
      border-radius: 20px;
      max-width: 900px;
      width: 100%;
      max-height: 90vh;
      overflow: hidden;
      border: 1px solid var(--border);
    }
    .modal-header {
      padding: 2rem;
      border-bottom: 1px solid var(--border);
      background: rgba(30, 30, 30, 0.9);
    }
    .modal-title {
      font-size: 1.8rem;
      font-weight: 700;
      color: var(--text-accent);
    }
    .modal-content {
      padding: 2rem;
      overflow-y: auto;
      max-height: 60vh;
    }
    .modal-footer {
      padding: 1.5rem 2rem;
      border-top: 1px solid var(--border);
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      background: rgba(30, 30, 30, 0.9);
    }
    /* Responsive Design */
    @media (max-width: 1200px) {
      .main-content {
        grid-template-columns: 1fr;
      }
    }
    @media (max-width: 768px) {
      body {
        padding: 12px;
      }
      .stopwatch-display {
        font-size: 3rem;
      }
      .controls-container {
        grid-template-columns: 1fr;
      }
      .stats-dashboard {
        grid-template-columns: 1fr;
      }
      .shadow-grid {
        grid-template-columns: 1fr;
      }
      .favorites-grid {
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      }
      .task-input-container {
        flex-direction: column;
      }
    }
    @media (max-width: 480px) {
      header {
        flex-direction: column;
        gap: 1rem;
      }
      .app-title {
        font-size: 1.4rem;
      }
      .stopwatch-display {
        font-size: 2.5rem;
      }
      .motivation-container {
        padding: 1rem;
        font-size: 1rem;
      }
      .date-display {
        flex-direction: column;
        gap: 1rem;
        text-align: center;
      }
    }
  </style>
</head>
<body>
  <!-- Streak Popup -->
  <div class="streak-popup-overlay" id="streak-popup">
    <div class="streak-popup">
      <div class="streak-icon">
        <i class="fas fa-fire"></i>
      </div>
      <h2>STREAK MAINTAINED</h2>
      <div class="streak-count" id="streak-count">0</div>
      <div class="streak-message" id="streak-message"></div>
      <button class="btn btn-primary" id="close-streak">CONTINUE</button>
    </div>
  </div>
  <!-- Motivation -->
  <div class="motivation-container">
    <div id="motivation-line">Excellence is not a singular act, but a habit. You are what you repeatedly do.</div>
  </div>
  <!-- Main App Container -->
  <div class="app-container">
    <!-- Header -->
    <header>
      <h1 class="app-title">
        <i class="fas fa-stopwatch"></i> DISCIPLINE TRACKER PRO
      </h1>
      <div class="view-controls">
        <button class="btn btn-primary" id="view-report">
          <i class="fas fa-chart-bar"></i> Report
        </button>
        <button class="btn" id="export-data">
          <i class="fas fa-download"></i> Export
        </button>
      </div>
    </header>
    <!-- Date and Time Display -->
    <div class="date-display">
      <div id="current-date">February 8, 2026</div>
      <div id="current-time">14:30:45</div>
    </div>
    <!-- Stats Dashboard -->
    <div class="stats-dashboard">
      <div class="stat-card">
        <div class="stat-value stat-productive" id="productive-time">0h 0m</div>
        <div class="stat-label">Productive Today</div>
      </div>
      <div class="stat-card">
        <div class="stat-value stat-sleep" id="sleep-time">0h 0m</div>
        <div class="stat-label">Sleep Today</div>
      </div>
      <div class="stat-card">
        <div class="stat-value stat-total" id="total-time">0h 0m</div>
        <div class="stat-label">Total Tracked</div>
      </div>
      <div class="stat-card">
        <div class="stat-value stat-streak" id="streak-display">0</div>
        <div class="stat-label">Day Streak</div>
      </div>
    </div>

    <!-- SHADOW Engine -->
    <section class="shadow-section">
      <h2 class="shadow-title">SHADOW</h2>
      <div class="shadow-grid">
        <div class="shadow-card" id="shadow-current-card">
          <div class="shadow-card-title">âš” Current You</div>
          <div class="shadow-verdict" id="shadow-verdict">Verdict loading...</div>
          <div class="shadow-subtitle">Today Battle</div>
          <div class="shadow-main-value" id="shadow-current-minutes">0h 00m</div>
          <div class="shadow-line">Gap vs Shadow: <strong id="shadow-gap" class="shadow-gap-equal">0h 00m</strong></div>
          <div class="shadow-line">Need to tie today: <strong id="shadow-needed-tie">0h 00m</strong></div>
          <div class="shadow-line">Need to lead today: <strong id="shadow-needed-lead">0h 00m</strong></div>
          <div class="shadow-line">Shadow Defense Target (tomorrow): <strong id="shadow-defense-target">0h 00m</strong></div>
          <div class="shadow-line">Reached: <strong id="shadow-percent">0%</strong></div>
          <div class="shadow-line">Penalty: <strong id="shadow-penalty" class="shadow-gap-positive">-0h 00m</strong></div>
          <div class="shadow-subtitle">Daily Mission</div>
          <div class="shadow-goal-list">
            <div class="shadow-goal-item"><span>NPTEL (2h / 2 videos)</span><strong id="goal-nptel">0m â€¢ 0/2</strong></div>
            <div class="shadow-goal-item"><span>YouTube Learning (2h / 2 videos)</span><strong id="goal-yt">0m â€¢ 0/2</strong></div>
            <div class="shadow-goal-item"><span>Project Work (3h)</span><strong id="goal-project">0m</strong></div>
          </div>
          <div>
            <span class="shadow-badge" id="shadow-status">OUT OF RANGE</span>
            <span class="shadow-badge" id="shadow-pressure">Pressure: High</span>
          </div>
          <div class="shadow-progress">
            <div class="shadow-progress-fill" id="shadow-progress-fill"></div>
          </div>
        </div>
        <div class="shadow-card" id="shadow-standard-card">
          <div class="shadow-card-title">ðŸŒ‘ The Shadow</div>
          <div class="shadow-main-value" id="shadow-average">0h 00m</div>
          <div class="shadow-subtitle">Monthly Battle</div>
          <div>
            <span class="shadow-badge" id="shadow-rank">Rank: Initiate</span>
            <span class="shadow-badge" id="shadow-badge">Baseline</span>
          </div>
          <div>
            <span class="shadow-badge" id="shadow-score">Monthly Score: You 0 - Shadow 0</span>
            <span class="shadow-badge" id="shadow-duel">Leader: Even</span>
            <span class="shadow-badge" id="shadow-lead-margin">Lead Margin: 0</span>
            <span class="shadow-badge" id="shadow-trend">Monthly trend: 0%</span>
          </div>
          <div class="shadow-line">Weekly 7-Day Avg: <strong id="shadow-weekly-average">0h 00m</strong></div>
          <div class="shadow-line">Momentum: <strong id="shadow-momentum" class="shadow-momentum-flat">Stable</strong></div>
          <div class="shadow-line">Weekly Delta vs Shadow: <strong id="shadow-weekly-gap" class="shadow-gap-equal">0h 00m</strong></div>
          <div class="shadow-line">Today's Target: <strong id="shadow-target">0h 00m</strong></div>
          <div class="shadow-duel-bar">
            <div class="shadow-duel-you"><div class="shadow-duel-you-fill" id="shadow-duel-you-fill"></div></div>
            <div class="shadow-duel-shadow"><div class="shadow-duel-shadow-fill" id="shadow-duel-shadow-fill"></div></div>
          </div>
          <div class="shadow-line">Your Strongest Historical 7-Day Standard</div>
          <div class="shadow-line" id="shadow-note">Calculated from real historical data only</div>
        </div>
      </div>
    </section>
    <!-- Main Content -->
    <div class="main-content">
      <!-- Stopwatch Section -->
      <div class="stopwatch-container">
        <!-- Stopwatch Display -->
        <div class="stopwatch-display" id="stopwatch">00:00:00</div>
        <!-- Task Input -->
        <div class="task-input-container">
          <input type="text" class="task-input" id="task-input" placeholder="Enter task name..." maxlength="50" />
          <button class="btn btn-success" id="add-favorite" title="Add to favorites">
            <i class="far fa-star"></i>
          </button>
        </div>
        <!-- Controls -->
        <div class="controls-container">
          <button class="btn btn-success" id="start-btn">
            <i class="fas fa-play"></i>
            <span>Start</span>
          </button>
          <button class="btn btn-danger" id="stop-btn" disabled>
            <i class="fas fa-stop"></i>
            <span>Stop</span>
          </button>
          <button class="btn btn-primary" id="sleep-btn">
            <i class="fas fa-bed"></i>
            <span>Sleep</span>
          </button>
        </div>
        <!-- Active Task Indicator -->
        <div id="active-task-indicator" style="display: none;">
          <div class="active-task-indicator">
            <strong><i class="fas fa-running"></i> Active Task:</strong>
            <span id="active-task-name"></span>
            <br>
            <small>Started at: <span id="active-task-start"></span></small>
          </div>
        </div>
        <!-- Favorites Section -->
        <h3 class="section-title">
          <i class="fas fa-star"></i> Quick Start Favorites
        </h3>
        <div class="favorites-grid" id="favorites-grid">
          <!-- Favorites will be dynamically inserted here -->
        </div>
        <!-- Today's Tasks -->
        <h3 class="section-title">
          <i class="fas fa-tasks"></i> Today's Activities
        </h3>
        <div class="tasks-list" id="tasks-list">
          <!-- Tasks will be dynamically inserted here -->
        </div>

      </div>
      <!-- Graphs Section -->
      <div class="graphs-container">
        <!-- Productivity Graph -->
        <div class="graph-card">
          <div class="graph-header">
            <div class="graph-title">
              <i class="fas fa-chart-line"></i>
              Productivity Trend
            </div>
            <div class="graph-controls">
              <select class="range-select" id="prod-range">
                <option value="7d">7 Days</option>
                <option value="30d">30 Days</option>
                <option value="3m">3 Months</option>
                <option value="6m">6 Months</option>
                <option value="1y">1 Year</option>
              </select>
              <select class="range-select" id="prod-filter">
                <option value="all">All</option>
                <option value="productivity">Productivity</option>
                <option value="distraction">Distraction</option>
                <option value="neutral">Neutral</option>
                <option value="high_waste">High Waste Only</option>
              </select>
              <span class="prod-total-counter" id="prod-filter-total">0h 00m</span>
            </div>
          </div>
          <div class="graph-canvas-container">
            <canvas id="productivity-chart"></canvas>
          </div>
        </div>
        <!-- Sleep Graph -->
        <div class="graph-card">
          <div class="graph-header">
            <div class="graph-title">
              <i class="fas fa-bed"></i>
              Sleep Analysis
            </div>
            <div class="graph-controls">
              <select class="range-select" id="sleep-range">
                <option value="7d">7 Days</option>
                <option value="30d">30 Days</option>
                <option value="3m">3 Months</option>
                <option value="6m">6 Months</option>
                <option value="1y">1 Year</option>
              </select>
            </div>
          </div>
          <div class="graph-canvas-container">
            <canvas id="sleep-chart"></canvas>
          </div>
        </div>
      </div>
    </div>
  </div>
  <!-- Report Modal -->
  <div class="modal-overlay" id="report-modal">
    <div class="modal">
      <div class="modal-header">
        <h2 class="modal-title">Performance Report</h2>
        <button class="btn" id="close-modal" style="position: absolute; right: 20px; top: 20px;">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div class="modal-content" id="report-content">
        <!-- Report content will be dynamically inserted -->
      </div>
      <div class="modal-footer">
        <button class="btn" id="print-report">
          <i class="fas fa-print"></i> Print
        </button>
        <button class="btn btn-primary" id="close-report">
          Close
        </button>
      </div>
    </div>
  </div>
  <script>
    // ==============================================
    // Discipline Tracker Pro - Extended Logic/Data/Reporting
    // ==============================================
    const CONFIG = {
      DB_SCHEMA_VERSION: 2,
      DAILY_PRODUCTIVITY_THRESHOLD_MINUTES: 240,
      STORAGE_KEYS: {
        TASKS: 'discipline_tracker_tasks',
        FAVORITES: 'discipline_tracker_favorites',
        STREAK: 'discipline_tracker_streak',
        LAST_ACTIVITY: 'discipline_tracker_last_activity',
        ACTIVE_TASK: 'discipline_tracker_active_task',
        SCHEMA_VERSION: 'discipline_tracker_schema_version',
        SYNC_ENDPOINT: 'discipline_tracker_sync_endpoint',
        SYNC_DEVICE_ID: 'discipline_tracker_device_id',
        SYNC_QUEUE: 'discipline_tracker_sync_queue',
        SHADOW_AVG: 'discipline_tracker_shadow_avg'
      },
      MOTIVATION_INTERVAL: 15000,
      CHART_RANGES: { '7d': 7, '30d': 30, '3m': 90, '6m': 180, '1y': 365 },
      DAILY_GOALS: [
        { id: 'nptel', label: 'NPTEL', minutesTarget: 120, sessionsTarget: 2, keywords: ['nptel'] },
        { id: 'yt', label: 'YouTube Learning', minutesTarget: 120, sessionsTarget: 2, keywords: ['youtube', 'yt'] },
        { id: 'project', label: 'Project Work', minutesTarget: 180, sessionsTarget: 0, keywords: ['project'] }
      ]
    };
    const CATEGORY_DEFINITIONS = {
      'Sleep': ['Night Sleep', 'Nap', 'Recovery'],
      'Productive Work': ['Analog', 'PCB', 'Coding', 'Control Systems', 'Planning', 'Execution'],
      'Physical Training': ['Chest', 'Back', 'Legs', 'Arms', 'Conditioning', 'Mobility'],
      'Study / Skill Development': ['Reading', 'Course', 'Practice', 'Research'],
      'Time Waste / Distraction': ['Social Media', 'Streaming', 'Gaming', 'Browsing', 'Idle'],
      'Miscellaneous': ['Admin', 'Commute', 'Family', 'Other']
    };
    const CATEGORY_ALIASES = {
      sleep: 'Sleep',
      rest: 'Sleep',
      productive: 'Productive Work',
      work: 'Productive Work',
      training: 'Physical Training',
      physical: 'Physical Training',
      workout: 'Physical Training',
      study: 'Study / Skill Development',
      skill: 'Study / Skill Development',
      learning: 'Study / Skill Development',
      waste: 'Time Waste / Distraction',
      distraction: 'Time Waste / Distraction',
      misc: 'Miscellaneous',
      miscellaneous: 'Miscellaneous'
    };
    const PRODUCTIVE_CATEGORIES = new Set(['Productive Work', 'Physical Training', 'Study / Skill Development']);
    // Logical schema (local + cloud payload)
    // activity_entry: {
    //   id, category, subcategory, startTime, endTime, duration, date,
    //   description(optional), sourceDevice, createdAt, updatedAt
    // }
    const MOTIVATION_LINES = [
      "Excellence is not a singular act, but a habit. You are what you repeatedly do.",
      "Discipline is the bridge between goals and accomplishment.",
      "The comeback is always stronger than the setback. Keep grinding.",
      "No shortcuts. No excuses. Just relentless execution.",
      "Consistency beats intensity every single time. Show up daily.",
      "Pain is temporary. Quitting lasts forever. Choose your hard.",
      "Your discipline today is your freedom tomorrow.",
      "Grind in silence, let success make the noise.",
      "Fall seven times, stand up eight. This is discipline.",
      "Small daily improvements lead to staggering long-term results.",
      "The only limit is the one you set yourself. Break it.",
      "Action is the antidote to anxiety. Keep moving forward.",
      "Don't stop when you're tired. Stop when you're done.",
      "The only bad workout is the one that didn't happen.",
      "Success is the sum of small efforts, repeated day in and day out.",
      "Your future is created by what you do today, not tomorrow.",
      "The harder you work for something, the greater you'll feel when you achieve it.",
      "Discipline is doing what needs to be done even when you don't want to.",
      "Be so good they can't ignore you. Master your craft.",
      "The only way to achieve the impossible is to believe it is possible."
    ];
    const STREAK_MESSAGES = {
      1: "Day one. This is where it begins.", 3: "Three days strong. Momentum is building.",
      7: "One week! Discipline is becoming a habit.", 14: "Two weeks. You're building something real.",
      21: "Three weeks. This is who you are now.", 30: "One month of discipline. Elite status.",
      60: "Two months. You've transformed.", 90: "Three months. Unstoppable.",
      100: "Century streak. This is your identity.", 365: "One year. You've mastered yourself."
    };

    class ActivityClassifier {
      static classify(activityInput) {
        const activity = (activityInput || '').trim();
        const text = activity.toLowerCase();

        const strongDistraction = ['random', 'scrolling', 'reels', 'timepass', 'doomscroll', 'binge', 'procrastination'];
        const distractionKeywords = ['instagram', 'tiktok', 'youtube shorts', 'gaming', 'games', 'twitter', 'x app', 'reddit', 'netflix', 'series', 'memes', 'chatting'];
        const productiveKeywords = ['coding', 'project', 'study', 'learning', 'course', 'workout', 'exercise', 'gym', 'chest', 'back', 'legs', 'pcb', 'analog', 'control systems', 'research', 'writing', 'build'];
        const neutralKeywords = ['commute', 'cleaning', 'meal', 'eating', 'shopping', 'family', 'chores', 'admin', 'errands', 'restroom'];

        let productiveScore = 0;
        let distractionScore = 0;
        let neutralScore = 0;

        strongDistraction.forEach(k => { if (text.includes(k)) distractionScore += 5; });
        distractionKeywords.forEach(k => { if (text.includes(k)) distractionScore += 3; });
        productiveKeywords.forEach(k => { if (text.includes(k)) productiveScore += 3; });
        neutralKeywords.forEach(k => { if (text.includes(k)) neutralScore += 2; });

        if (!text) neutralScore += 1;

        let category = 'NEUTRAL';
        let graph_tag = 'neutral';
        if (distractionScore > productiveScore && distractionScore >= neutralScore) {
          category = 'DISTRACTION';
          graph_tag = 'distraction';
        } else if (productiveScore > distractionScore && productiveScore >= neutralScore) {
          category = 'PRODUCTIVE';
          graph_tag = 'productivity';
        }

        const maxScore = Math.max(productiveScore, distractionScore, neutralScore, 1);
        const secondScore = [productiveScore, distractionScore, neutralScore].sort((a, b) => b - a)[1] || 0;
        const confidence = Math.max(40, Math.min(100, Math.round(55 + (maxScore - secondScore) * 9)));

        let waste_level = 'NONE';
        if (category === 'DISTRACTION') {
          if (strongDistraction.some(k => text.includes(k)) || distractionScore >= 8) waste_level = 'HIGH';
          else if (distractionScore >= 5) waste_level = 'MODERATE';
          else waste_level = 'LOW';
        }

        return {
          activity,
          category,
          confidence,
          waste_level,
          graph_tag
        };
      }
    }
    class SyncManager {
      constructor(app) { this.app = app; }
      get endpoint() { return localStorage.getItem(CONFIG.STORAGE_KEYS.SYNC_ENDPOINT); }
      getDeviceId() {
        let id = localStorage.getItem(CONFIG.STORAGE_KEYS.SYNC_DEVICE_ID);
        if (!id) {
          id = `device-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
          localStorage.setItem(CONFIG.STORAGE_KEYS.SYNC_DEVICE_ID, id);
        }
        return id;
      }
      queue(change) {
        const q = this.app.loadFromStorage(CONFIG.STORAGE_KEYS.SYNC_QUEUE) || [];
        q.push(change);
        this.app.saveToStorage(CONFIG.STORAGE_KEYS.SYNC_QUEUE, q);
      }
      async flushQueue() {
        if (!navigator.onLine || !this.endpoint) return;
        const queue = this.app.loadFromStorage(CONFIG.STORAGE_KEYS.SYNC_QUEUE) || [];
        if (!queue.length) return;
        try {
          await fetch(this.endpoint, {
            method: 'POST', headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ deviceId: this.getDeviceId(), changes: queue })
          });
          this.app.saveToStorage(CONFIG.STORAGE_KEYS.SYNC_QUEUE, []);
        } catch (e) { console.warn('Sync flush failed:', e); }
      }
      async pullLatest() {
        if (!navigator.onLine || !this.endpoint) return;
        try {
          const res = await fetch(`${this.endpoint}?deviceId=${encodeURIComponent(this.getDeviceId())}`);
          if (!res.ok) return;
          const payload = await res.json();
          if (!Array.isArray(payload.entries)) return;
          this.app.taskManager.mergeTasks(payload.entries.map(t => this.app.normalizeTask(t)));
        } catch (e) { console.warn('Cloud pull failed:', e); }
      }
      async syncNow() { await this.flushQueue(); await this.pullLatest(); }
    }
    class DisciplineTracker {
      constructor() {
        this.state = {
          tasks: (this.loadFromStorage(CONFIG.STORAGE_KEYS.TASKS) || []).map(t => this.normalizeTask(t)),
          favorites: this.loadFromStorage(CONFIG.STORAGE_KEYS.FAVORITES) || [],
          streak: parseInt(this.loadFromStorage(CONFIG.STORAGE_KEYS.STREAK)) || 0,
          lastActivityDate: this.loadFromStorage(CONFIG.STORAGE_KEYS.LAST_ACTIVITY),
          activeTask: this.loadFromStorage(CONFIG.STORAGE_KEYS.ACTIVE_TASK),
          charts: { productivity: null, sleep: null }
        };
        this.elements = this.initializeElements();
        this.syncManager = new SyncManager(this);
        this.stopwatch = new StopwatchManager(this);
        this.taskManager = new TaskManager(this);
        this.uiManager = new UIManager(this);
        this.shadowEngine = new ShadowEngine(this);
        this.graphManager = new GraphManager(this);
        this.eventManager = new EventManager(this);
        this.migrateSchema();
      }
      initializeElements() {
        const elements = {};
        ['stopwatch','task-input','start-btn','stop-btn','sleep-btn','add-favorite','active-task-indicator','active-task-name','active-task-start','favorites-grid','tasks-list','productive-time','sleep-time','total-time','streak-display','current-date','current-time','motivation-line','prod-range','prod-filter','prod-filter-total','sleep-range','productivity-chart','sleep-chart','streak-popup','streak-count','streak-message','close-streak','view-report','export-data','report-modal','report-content','close-modal','print-report','close-report','shadow-current-card','shadow-standard-card','shadow-current-minutes','shadow-percent','shadow-gap','shadow-status','shadow-progress-fill','shadow-average','shadow-rank','shadow-badge','shadow-duel','shadow-note','shadow-weekly-average','shadow-momentum','shadow-weekly-gap','shadow-target','shadow-pressure','shadow-score','shadow-needed-tie','shadow-needed-lead','shadow-defense-target','shadow-verdict','shadow-trend','shadow-lead-margin','shadow-duel-you-fill','shadow-duel-shadow-fill','shadow-penalty','goal-nptel','goal-yt','goal-project'].forEach(id => elements[id] = document.getElementById(id));
        return elements;
      }
      loadFromStorage(key) { try { const d = localStorage.getItem(key); return d ? JSON.parse(d) : null; } catch { return null; } }
      saveToStorage(key, data) { try { localStorage.setItem(key, JSON.stringify(data)); } catch (e) { console.error('storage save failed', e); } }
      migrateSchema() {
        const current = parseInt(this.loadFromStorage(CONFIG.STORAGE_KEYS.SCHEMA_VERSION)) || 1;
        if (current < CONFIG.DB_SCHEMA_VERSION) {
          this.state.tasks = this.state.tasks.map(t => this.normalizeTask(t));
          this.saveToStorage(CONFIG.STORAGE_KEYS.TASKS, this.state.tasks);
          this.saveToStorage(CONFIG.STORAGE_KEYS.SCHEMA_VERSION, CONFIG.DB_SCHEMA_VERSION);
        }
      }
      normalizeTask(task) {
        const isLegacySleep = task.isSleep === true || task.category === 'Sleep';
        const category = this.resolveCategory(task.category || (isLegacySleep ? 'Sleep' : 'Miscellaneous'));
        const fallbackSub = CATEGORY_DEFINITIONS[category]?.[0] || 'General';
        const subcategory = task.subcategory || (isLegacySleep ? 'Night Sleep' : fallbackSub);
        const description = task.description || task.name || '';
        const startTime = Number(task.startTime || Date.now());
        const endTime = Number(task.endTime || startTime);
        const rawDuration = task.duration ?? Math.round((endTime - startTime) / 60000);
        const duration = Math.min(24 * 60, Math.max(0, Number.isFinite(rawDuration) ? rawDuration : 0));

        const classifierInput = (task.description || task.name || '').trim();
        const classification = ActivityClassifier.classify(classifierInput);

        // Context-aware correction so graph filters remain reliable:
        // category intent from user selection is respected over weak text hints.
        if (category === 'Time Waste / Distraction') {
          classification.category = 'DISTRACTION';
          classification.graph_tag = 'distraction';
          if (classification.waste_level === 'NONE') classification.waste_level = duration >= 90 ? 'HIGH' : (duration >= 30 ? 'MODERATE' : 'LOW');
          classification.confidence = Math.max(75, classification.confidence);
        } else if (PRODUCTIVE_CATEGORIES.has(category)) {
          classification.category = 'PRODUCTIVE';
          classification.graph_tag = 'productivity';
          classification.waste_level = 'NONE';
          classification.confidence = Math.max(70, classification.confidence);
        } else if (category === 'Sleep' || category === 'Miscellaneous') {
          classification.category = 'NEUTRAL';
          classification.graph_tag = 'neutral';
          classification.waste_level = 'NONE';
          classification.confidence = Math.max(60, classification.confidence);
        }

        const graphTag = task.graph_tag || classification.graph_tag;
        const wasteLevel = task.waste_level || classification.waste_level;
        const growthCategory = task.growth_category || classification.category;
        const confidence = Number(task.confidence ?? classification.confidence);

        return {
          id: task.id || `${startTime}-${Math.random().toString(36).slice(2, 8)}`,
          category, subcategory, description,
          startTime, endTime, duration,
          date: task.date || this.getDateString(new Date(startTime)),
          sourceDevice: task.sourceDevice || this.syncManager?.getDeviceId?.() || 'local',
          createdAt: task.createdAt || Date.now(),
          updatedAt: Date.now(),
          growth_category: growthCategory,
          confidence,
          waste_level: wasteLevel,
          graph_tag: graphTag,
          classification_json: {
            activity: task.description || task.name || '',
            category: growthCategory,
            confidence,
            waste_level: wasteLevel,
            graph_tag: graphTag
          }
        };
      }
      getDateString(date = new Date()) { const d = new Date(date); return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`; }
      getInferredWasteMinutesForDate(dateStr, sourceTasks = this.state.tasks) {
        const trackedMinutes = sourceTasks
          .filter(task => task.date === dateStr && Number.isFinite(task.duration) && task.duration > 0)
          .reduce((sum, task) => sum + task.duration, 0);
        return Math.max(0, 1440 - Math.min(1440, trackedMinutes));
      }
      formatDuration(minutes) { const h=Math.floor(minutes/60),m=Math.floor(minutes%60); return `${h}h ${String(m).padStart(2,'0')}m`; }
      formatTime(ts) { return new Date(ts).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); }
      isProductiveCategory(category) { return PRODUCTIVE_CATEGORIES.has(category); }
      resolveCategory(inputCategory) {
        const categories = Object.keys(CATEGORY_DEFINITIONS);
        if (!inputCategory) return 'Miscellaneous';
        const normalized = String(inputCategory).trim().toLowerCase();
        const exact = categories.find(c => c.toLowerCase() === normalized);
        if (exact) return exact;
        if (CATEGORY_ALIASES[normalized]) return CATEGORY_ALIASES[normalized];
        const loose = categories.find(c => c.toLowerCase().includes(normalized) || normalized.includes(c.toLowerCase()));
        return loose || 'Miscellaneous';
      }
      async initialize() {
        if (!window.Chart) { try { await this.loadChartJS(); } catch {} }
        this.uiManager.initialize(); this.taskManager.initialize(); this.shadowEngine.initialize(); this.graphManager.initialize(); this.eventManager.initialize();
        this.updateStreak();
        if (this.state.activeTask) this.stopwatch.resumeActiveTask(this.state.activeTask);
        window.addEventListener('online', () => this.syncManager.syncNow());
        await this.syncManager.syncNow();
      }
      loadChartJS() { return new Promise((resolve, reject) => { const s=document.createElement('script'); s.src='https://cdn.jsdelivr.net/npm/chart.js'; s.onload=resolve; s.onerror=reject; document.head.appendChild(s); }); }
      updateStreak(showPopup = false) {
        const dates = [...new Set(this.state.tasks.map(t => t.date))].sort();
        if (!dates.length) { this.state.streak=0; this.elements['streak-display'].textContent=0; return; }
        const set = new Set(dates); const today = this.getDateString();
        let streak=0; let cursor=set.has(today)?today:this.getDateString(new Date(Date.now()-86400000));
        while (set.has(cursor)) { streak++; const d=new Date(cursor); d.setDate(d.getDate()-1); cursor=this.getDateString(d); }
        const old=this.state.streak; this.state.streak=streak;
        this.saveToStorage(CONFIG.STORAGE_KEYS.STREAK, streak); this.elements['streak-display'].textContent=streak;
        if (showPopup && streak > old && streak > 1) this.uiManager.showStreakPopup();
      }
    }
    class StopwatchManager {
      constructor(app) { this.app = app; this.startTime = null; this.elapsedTime = 0; this.animationFrameId = null; this.isRunning = false; this.pendingMeta = null; }
      collectEntryMetadata(taskName, forceCategory = null) {
        const categories = Object.keys(CATEGORY_DEFINITIONS);
        const defaultCategory = forceCategory || 'Productive Work';
        const categoryInput = prompt(`Category (${categories.join(' | ')})`, defaultCategory);
        if (categoryInput === null) return null;
        const category = this.app.resolveCategory(categoryInput) || defaultCategory;
        const subList = CATEGORY_DEFINITIONS[category] || ['General'];
        const subInput = prompt(`Subcategory for ${category} (${subList.join(' | ')})`, subList[0]);
        if (subInput === null) return null;
        const subcategory = subInput.trim() || subList[0];
        const description = (this.app.elements['task-input'].value.trim() || taskName || '').slice(0, 120);
        return { category, subcategory, description };
      }
      start(taskName = null, meta = null) {
        if (this.isRunning) return alert('A task is already running. Stop it first.');
        const name = taskName || this.app.elements['task-input'].value.trim();
        if (!name && !meta) return alert('Please enter a task name');
        const resolvedMeta = meta || this.collectEntryMetadata(name, null);
        if (!resolvedMeta) return;
        this.startTime = Date.now(); this.isRunning = true; this.elapsedTime = 0;
        this.app.state.activeTask = { name: name || resolvedMeta.subcategory, startTime: this.startTime, ...resolvedMeta };
        this.app.saveToStorage(CONFIG.STORAGE_KEYS.ACTIVE_TASK, this.app.state.activeTask);
        this.app.elements['start-btn'].disabled = true; this.app.elements['stop-btn'].disabled = false; this.app.elements['task-input'].disabled = true;
        this.app.elements['active-task-name'].textContent = `${this.app.state.activeTask.category} â€¢ ${this.app.state.activeTask.subcategory}`;
        this.app.elements['active-task-start'].textContent = this.app.formatTime(this.startTime); this.app.elements['active-task-indicator'].style.display = 'block';
        this.update();
      }
      startSleep() { this.start('Sleep', { category: 'Sleep', subcategory: 'Night Sleep', description: 'Sleep Session' }); }
      update() {
        if (!this.isRunning) return;
        this.elapsedTime = Date.now() - this.startTime;
        const h=Math.floor(this.elapsedTime/3600000),m=Math.floor((this.elapsedTime%3600000)/60000),s=Math.floor((this.elapsedTime%60000)/1000);
        this.app.elements['stopwatch'].textContent = `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
        this.animationFrameId = requestAnimationFrame(() => this.update());
      }
      stop() {
        if (!this.isRunning) return;
        this.isRunning = false; if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        const endTime = Date.now();
        const entry = this.app.normalizeTask({
          id: `${Date.now()}`,
          ...this.app.state.activeTask,
          startTime: this.startTime,
          endTime,
          duration: Math.max(1, Math.round((endTime - this.startTime) / 60000)),
          date: this.app.getDateString(new Date(this.startTime))
        });
        this.app.taskManager.addTask(entry);
        this.reset();
      }
      reset() {
        this.isRunning=false; this.startTime=null; this.elapsedTime=0; if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        this.app.state.activeTask=null; this.app.saveToStorage(CONFIG.STORAGE_KEYS.ACTIVE_TASK, null);
        this.app.elements['stopwatch'].textContent='00:00:00'; this.app.elements['start-btn'].disabled=false; this.app.elements['stop-btn'].disabled=true;
        this.app.elements['task-input'].disabled=false; this.app.elements['active-task-indicator'].style.display='none'; this.app.elements['task-input'].value='';
      }
      resumeActiveTask(activeTask) {
        if (!activeTask?.startTime) return;
        this.startTime = activeTask.startTime; this.isRunning = true; this.app.state.activeTask = activeTask;
        this.app.elements['start-btn'].disabled = true; this.app.elements['stop-btn'].disabled = false; this.app.elements['task-input'].disabled = true;
        this.app.elements['active-task-name'].textContent = `${activeTask.category || 'Productive Work'} â€¢ ${activeTask.subcategory || 'General'}`;
        this.app.elements['active-task-start'].textContent = this.app.formatTime(activeTask.startTime); this.app.elements['active-task-indicator'].style.display = 'block';
        this.update();
      }
    }
    class TaskManager {
      constructor(app) { this.app = app; }
      initialize() { this.updateStats(); this.renderTasks(); this.renderFavorites(); }
      mergeTasks(incoming) {
        const map = new Map(this.app.state.tasks.map(t => [t.id, t]));
        incoming.forEach(t => map.set(t.id, this.app.normalizeTask(t)));
        this.app.state.tasks = [...map.values()].sort((a,b) => a.startTime - b.startTime);
        this.app.saveToStorage(CONFIG.STORAGE_KEYS.TASKS, this.app.state.tasks);
        this.updateStats(); this.renderTasks(); this.app.graphManager.updateCharts(); this.app.updateStreak();
      }
      addTask(task) {
        this.app.state.tasks.push(this.app.normalizeTask(task));
        this.app.saveToStorage(CONFIG.STORAGE_KEYS.TASKS, this.app.state.tasks);
        this.app.syncManager.queue({ type: 'upsert', entry: task, ts: Date.now() });
        this.app.syncManager.flushQueue();
        this.updateStats(); this.renderTasks(); this.app.graphManager.updateCharts(); this.app.updateStreak(true);
      }
      deleteTask(taskId) {
        this.app.state.tasks = this.app.state.tasks.filter(task => task.id !== taskId);
        this.app.saveToStorage(CONFIG.STORAGE_KEYS.TASKS, this.app.state.tasks);
        this.app.syncManager.queue({ type: 'delete', id: taskId, ts: Date.now() });
        this.updateStats(); this.renderTasks(); this.app.graphManager.updateCharts(); this.app.updateStreak();
      }
      updateStats() {
        const today = this.app.getDateString();
        const todayTasks = this.app.state.tasks.filter(task => task.date === today);
        const productiveTime = todayTasks.filter(task => this.app.isProductiveCategory(task.category)).reduce((t, task) => t + task.duration, 0);
        const sleepTime = todayTasks.filter(task => task.category === 'Sleep').reduce((t, task) => t + task.duration, 0);
        const totalTime = todayTasks.reduce((t, task) => t + task.duration, 0);
        this.app.elements['productive-time'].textContent = this.app.formatDuration(productiveTime);
        this.app.elements['sleep-time'].textContent = this.app.formatDuration(sleepTime);
        this.app.elements['total-time'].textContent = this.app.formatDuration(totalTime);

        if (this.app.shadowEngine) this.app.shadowEngine.refresh();
      }
      renderTasks() {
        const today = this.app.getDateString();
        const tasks = this.app.state.tasks.filter(task => task.date === today).sort((a,b) => b.startTime-a.startTime);
        const c = this.app.elements['tasks-list']; c.innerHTML = '';
        if (!tasks.length) {
          c.innerHTML = `<div style="text-align: center; padding: 3rem; color: var(--text-secondary);"><i class="fas fa-clipboard-list" style="font-size: 3rem; margin-bottom: 1rem;"></i><p>No tasks recorded today</p><p style="font-size: 0.9rem;">Start tracking your first task</p></div>`;
          return;
        }
        tasks.forEach(task => {
          const el=document.createElement('div');
          const isSleep = task.category === 'Sleep';
          el.className = `task-card ${isSleep ? 'sleep' : 'productive'}`;
          el.innerHTML = `<div class="task-header"><div class="task-name">${isSleep ? 'ðŸ’¤' : 'âš¡'} ${task.category} â€¢ ${task.subcategory}</div><div class="task-duration">${this.app.formatDuration(task.duration)}</div></div><div class="task-time">${this.app.formatTime(task.startTime)} - ${this.app.formatTime(task.endTime)}</div><div class="task-time">${task.description || ''}</div><div class="task-actions">${isSleep ? `<button class="btn edit-sleep-btn" data-id="${task.id}"><i class="fas fa-pen"></i> Edit Sleep</button>` : ''}<button class="btn delete-task-btn" data-id="${task.id}"><i class="fas fa-trash"></i> Delete</button></div>`;
          c.appendChild(el);
        });
        document.querySelectorAll('.delete-task-btn').forEach(btn => btn.addEventListener('click', e => this.deleteTask(e.currentTarget.getAttribute('data-id'))));
        document.querySelectorAll('.edit-sleep-btn').forEach(btn => btn.addEventListener('click', e => this.editSleepTask(e.currentTarget.getAttribute('data-id'))));
      }

      editSleepTask(taskId) {
        const task = this.app.state.tasks.find(t => t.id === taskId && t.category === 'Sleep');
        if (!task) return;

        const toEditable = (ts) => {
          const d = new Date(ts);
          const Y = d.getFullYear();
          const M = String(d.getMonth() + 1).padStart(2, '0');
          const D = String(d.getDate()).padStart(2, '0');
          const h = String(d.getHours()).padStart(2, '0');
          const m = String(d.getMinutes()).padStart(2, '0');
          return `${Y}-${M}-${D} ${h}:${m}`;
        };

        const parseEditable = (value) => {
          if (!value) return null;
          const parsed = new Date(value.replace(' ', 'T'));
          return Number.isNaN(parsed.getTime()) ? null : parsed.getTime();
        };

        const startInput = prompt('Sleep start (YYYY-MM-DD HH:mm)', toEditable(task.startTime));
        if (startInput === null) return;
        const endInput = prompt('Sleep end (YYYY-MM-DD HH:mm)', toEditable(task.endTime));
        if (endInput === null) return;

        const newStart = parseEditable(startInput.trim());
        const newEnd = parseEditable(endInput.trim());
        if (!newStart || !newEnd || newEnd <= newStart) {
          alert('Invalid sleep time range.');
          return;
        }

        task.startTime = newStart;
        task.endTime = newEnd;
        task.duration = Math.min(24 * 60, Math.max(1, Math.round((newEnd - newStart) / 60000)));
        task.date = this.app.getDateString(new Date(newStart));
        task.updatedAt = Date.now();

        this.app.saveToStorage(CONFIG.STORAGE_KEYS.TASKS, this.app.state.tasks);
        this.app.syncManager.queue({ type: 'upsert', entry: task, ts: Date.now() });
        this.app.syncManager.flushQueue();
        this.updateStats(); this.renderTasks(); this.app.graphManager.updateCharts(); this.app.updateStreak();
      }
      renderFavorites() {
        const container = this.app.elements['favorites-grid']; container.innerHTML='';
        if (!this.app.state.favorites.length) {
          container.innerHTML = `<div style="grid-column: 1 / -1; text-align: center; padding: 2rem; color: var(--text-secondary);"><i class="far fa-star" style="font-size: 2rem; margin-bottom: 0.5rem;"></i><p>No favorites yet</p><p style="font-size: 0.9rem;">Add tasks to favorites for quick start</p></div>`;
          return;
        }
        this.app.state.favorites.forEach((f, idx) => {
          const fav = typeof f === 'string' ? { label: f, category: 'Productive Work', subcategory: 'Execution' } : f;
          const el = document.createElement('div'); el.className='favorite-card';
          el.innerHTML = `<div class="favorite-name">${fav.label}</div><div class="favorite-actions"><button class="btn start-favorite-btn" data-index="${idx}"><i class="fas fa-play"></i></button><button class="btn remove-favorite-btn" data-index="${idx}"><i class="fas fa-times"></i></button></div>`;
          container.appendChild(el);
        });
        document.querySelectorAll('.start-favorite-btn').forEach(btn => btn.addEventListener('click', e => {
          const fav = this.app.state.favorites[parseInt(e.currentTarget.getAttribute('data-index'), 10)];
          const f = typeof fav === 'string' ? { label: fav, category: 'Productive Work', subcategory: 'Execution' } : fav;
          this.app.stopwatch.start(f.label, { category: f.category, subcategory: f.subcategory, description: f.label });
        }));
        document.querySelectorAll('.remove-favorite-btn').forEach(btn => btn.addEventListener('click', e => this.removeFavorite(parseInt(e.currentTarget.getAttribute('data-index'), 10))));
      }
      addFavorite() {
        const label = this.app.elements['task-input'].value.trim();
        if (!label) return alert('Please enter a task name to add to favorites');
        const category = this.app.resolveCategory(prompt('Favorite category', 'Productive Work'));
        const subcategory = prompt('Favorite subcategory', CATEGORY_DEFINITIONS[category]?.[0] || 'General') || 'General';
        const fav = { label, category, subcategory };
        this.app.state.favorites.push(fav);
        this.app.saveToStorage(CONFIG.STORAGE_KEYS.FAVORITES, this.app.state.favorites);
        this.renderFavorites();
      }
      removeFavorite(index) { this.app.state.favorites.splice(index,1); this.app.saveToStorage(CONFIG.STORAGE_KEYS.FAVORITES, this.app.state.favorites); this.renderFavorites(); }
    }
    class AnalyticsService {
      static buildMonthlyReport(tasks, year, month, thresholdMinutes = CONFIG.DAILY_PRODUCTIVITY_THRESHOLD_MINUTES) {
        const monthTasks = tasks.filter(t => { const d = new Date(t.startTime); return d.getFullYear() === year && d.getMonth() === month; });
        const pm = month === 0 ? 11 : month - 1;
        const py = month === 0 ? year - 1 : year;
        const prevTasks = tasks.filter(t => { const d = new Date(t.startTime); return d.getFullYear() === py && d.getMonth() === pm; });
        const totals = Object.fromEntries(Object.keys(CATEGORY_DEFINITIONS).map(c => [c, 0]));
        const daily = {};
        const daysInMonth = new Date(year, month + 1, 0).getDate();

        for (let day = 1; day <= daysInMonth; day++) {
          const date = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
          daily[date] = { productive: 0, sleep: 0, waste: 0, total: 0, inferredWaste: 0 };
        }

        monthTasks.forEach(t => {
          totals[t.category] = (totals[t.category] || 0) + t.duration;
          const day = daily[t.date] || (daily[t.date] = { productive: 0, sleep: 0, waste: 0, total: 0, inferredWaste: 0 });
          if (PRODUCTIVE_CATEGORIES.has(t.category)) day.productive += t.duration;
          if (t.category === 'Sleep') day.sleep += t.duration;
          if (t.category === 'Time Waste / Distraction') day.waste += t.duration;
          day.total += t.duration;
        });

        let inferredWasteMinutes = 0;
        Object.values(daily).forEach(day => {
          const inferredWaste = Math.max(0, 1440 - Math.min(1440, day.total));
          day.inferredWaste = inferredWaste;
          day.waste += inferredWaste;
          day.total += inferredWaste;
          inferredWasteMinutes += inferredWaste;
        });
        totals['Time Waste / Distraction'] = (totals['Time Waste / Distraction'] || 0) + inferredWasteMinutes;

        const totalMinutes = Object.values(totals).reduce((a,b) => a+b, 0);
        const productiveMinutes = Object.entries(totals).filter(([k]) => PRODUCTIVE_CATEGORIES.has(k)).reduce((a,[,v]) => a+v,0);
        const sleepMinutes = totals['Sleep'] || 0;
        const wasteMinutes = totals['Time Waste / Distraction'] || 0;
        const awakeMinutes = Math.max(0, totalMinutes - sleepMinutes);
        const activeDays = Math.max(1, daysInMonth);
        const productivityRatio = awakeMinutes ? productiveMinutes / awakeMinutes : 0;
        const pctByCategory = Object.fromEntries(Object.keys(totals).map(k => [k, totalMinutes ? (totals[k] / totalMinutes * 100) : 0]));
        const bestProductiveDay = Object.entries(daily).sort((a,b) => b[1].productive - a[1].productive)[0] || null;
        const worstWasteDay = Object.entries(daily).sort((a,b) => b[1].waste - a[1].waste)[0] || null;
        const sleepStreak = AnalyticsService.longestSleepConsistencyStreak(daily, 420);
        const underProductiveDays = Object.entries(daily).filter(([,v]) => v.productive < thresholdMinutes).length;
        const prevProductive = prevTasks.filter(t => PRODUCTIVE_CATEGORIES.has(t.category)).reduce((a,t)=>a+t.duration,0);
        const prevDaysInMonth = new Date(py, pm + 1, 0).getDate();
        const prevDailyTotals = {};
        for (let day = 1; day <= prevDaysInMonth; day++) {
          const date = `${py}-${String(pm + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
          prevDailyTotals[date] = 0;
        }
        prevTasks.forEach(t => {
          prevDailyTotals[t.date] = (prevDailyTotals[t.date] || 0) + t.duration;
        });
        const prevInferredWaste = Object.values(prevDailyTotals).reduce((sum, tracked) => sum + Math.max(0, 1440 - Math.min(1440, tracked)), 0);
        const prevWaste = prevTasks.filter(t => t.category === 'Time Waste / Distraction').reduce((a,t)=>a+t.duration,0) + prevInferredWaste;
        const productiveBreakdown = AnalyticsService.breakdown(monthTasks, 'Productive Work');
        const trainingBreakdown = AnalyticsService.breakdown(monthTasks, 'Physical Training');
        return {
          year, month,
          totals,
          totalMinutes,
          productiveMinutes,
          sleepMinutes,
          wasteMinutes,
          inferredWasteMinutes,
          awakeMinutes,
          pctByCategory,
          dailyAverageSleep: sleepMinutes / activeDays,
          dailyAverageProductive: productiveMinutes / activeDays,
          productivityRatio,
          daily,
          productiveBreakdown,
          trainingBreakdown,
          bestProductiveDay,
          worstWasteDay,
          sleepConsistency: { longestStreakDays: sleepStreak },
          alerts: { underProductivity: productiveMinutes < thresholdMinutes * activeDays, underProductiveDays, thresholdMinutes },
          improvement: {
            productiveDeltaMinutes: productiveMinutes - prevProductive,
            wasteDeltaMinutes: wasteMinutes - prevWaste
          }
        };
      }
      static breakdown(tasks, category) {
        const out = {};
        tasks.filter(t => t.category === category).forEach(t => out[t.subcategory] = (out[t.subcategory] || 0) + t.duration);
        return out;
      }
      static longestSleepConsistencyStreak(daily, targetMin) {
        const days = Object.keys(daily).sort();
        let best = 0; let run = 0;
        days.forEach(d => {
          if ((daily[d].sleep || 0) >= targetMin) { run += 1; best = Math.max(best, run); }
          else run = 0;
        });
        return best;
      }

      static buildSleepInsights(tasks) {
        const today = new Date();
        const daily = new Map();
        for (let i = 6; i >= 0; i--) {
          const d = new Date(today);
          d.setDate(today.getDate() - i);
          daily.set(`${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`, 0);
        }
        tasks.forEach(t => {
          if (t.category !== 'Sleep') return;
          if (daily.has(t.date)) daily.set(t.date, daily.get(t.date) + t.duration);
        });
        const values = [...daily.values()];
        const avg = values.reduce((a,b)=>a+b,0) / Math.max(values.length,1);
        const target = 480;
        const debt = target - avg;
        const variance = values.reduce((acc,v)=>acc + Math.pow(v - avg, 2), 0) / Math.max(values.length,1);
        const std = Math.sqrt(variance);
        let consistency = 'High';
        if (std > 90) consistency = 'Low';
        else if (std > 45) consistency = 'Moderate';
        return { averageLast7: avg, sleepDebt: debt, consistency, values };
      }
    }
    class UIManager {
      constructor(app) { this.app = app; this.currentMotivationIndex = 0; }
      initialize() { this.updateDateTime(); this.startMotivationRotation(); }
      updateDateTime() {
        const updateTime = () => {
          const now = new Date();
          this.app.elements['current-date'].textContent = now.toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
          this.app.elements['current-time'].textContent = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        }; updateTime(); setInterval(updateTime, 1000);
      }
      startMotivationRotation() { this.updateMotivation(); setInterval(() => this.updateMotivation(), CONFIG.MOTIVATION_INTERVAL); }
      updateMotivation() {
        const e = this.app.elements['motivation-line']; e.style.opacity = '0';
        setTimeout(() => { let n; do { n = Math.floor(Math.random() * MOTIVATION_LINES.length); } while (n === this.currentMotivationIndex && MOTIVATION_LINES.length > 1); this.currentMotivationIndex = n; e.textContent = MOTIVATION_LINES[n]; e.style.opacity = '1'; }, 500);
      }
      showStreakPopup() {
        const streak = this.app.state.streak; this.app.elements['streak-count'].textContent = streak;
        this.app.elements['streak-message'].textContent = STREAK_MESSAGES[streak] || `${streak} days strong. Keep going.`;
        this.app.elements['streak-popup'].style.display = 'flex';
      }
      hideStreakPopup() { this.app.elements['streak-popup'].style.display = 'none'; }
      showReport() {
        const now = new Date();
        const r = AnalyticsService.buildMonthlyReport(this.app.state.tasks, now.getFullYear(), now.getMonth());
        const monthName = now.toLocaleString('default', { month: 'long' });
        const rows = Object.keys(r.daily).sort().map(date => {
          const d = r.daily[date];
          return `<tr><td style="padding:0.75rem;border-bottom:1px solid var(--border);">${new Date(date).toLocaleDateString('en-US',{month:'short',day:'numeric',weekday:'short'})}</td><td style="padding:0.75rem;border-bottom:1px solid var(--border);">${this.app.formatDuration(d.productive)}</td><td style="padding:0.75rem;border-bottom:1px solid var(--border);">${this.app.formatDuration(d.sleep)}</td><td style="padding:0.75rem;border-bottom:1px solid var(--border);">${this.app.formatDuration(d.waste)}</td></tr>`;
        }).join('');
        const catRows = Object.entries(r.totals).map(([k,v]) => `<tr><td style="padding:0.75rem;border-bottom:1px solid var(--border);">${k}</td><td style="padding:0.75rem;border-bottom:1px solid var(--border);">${this.app.formatDuration(v)}</td><td style="padding:0.75rem;border-bottom:1px solid var(--border);">${r.pctByCategory[k].toFixed(1)}%</td></tr>`).join('');
        const prodBreak = Object.entries(r.productiveBreakdown).map(([k,v]) => `<tr><td style="padding:0.75rem;border-bottom:1px solid var(--border);">${k}</td><td style="padding:0.75rem;border-bottom:1px solid var(--border);">${this.app.formatDuration(v)}</td></tr>`).join('') || '<tr><td style="padding:0.75rem;" colspan="2">No entries</td></tr>';
        const trainBreak = Object.entries(r.trainingBreakdown).map(([k,v]) => `<tr><td style="padding:0.75rem;border-bottom:1px solid var(--border);">${k}</td><td style="padding:0.75rem;border-bottom:1px solid var(--border);">${this.app.formatDuration(v)}</td></tr>`).join('') || '<tr><td style="padding:0.75rem;" colspan="2">No entries</td></tr>';
        const best = r.bestProductiveDay ? `${r.bestProductiveDay[0]} (${this.app.formatDuration(r.bestProductiveDay[1].productive)})` : 'N/A';
        const worst = r.worstWasteDay ? `${r.worstWasteDay[0]} (${this.app.formatDuration(r.worstWasteDay[1].waste)})` : 'N/A';
        const sleepInsights = AnalyticsService.buildSleepInsights(this.app.state.tasks);
        const summaryRows = [
          ['Total Sleep', this.app.formatDuration(r.sleepMinutes)],
          ['Total Productive', this.app.formatDuration(r.productiveMinutes)],
          ['Total Waste', `${this.app.formatDuration(r.wasteMinutes)} (Untracked: ${this.app.formatDuration(r.inferredWasteMinutes)})`],
          ['Total Awake', this.app.formatDuration(r.awakeMinutes)],
          ['Productivity Ratio', `${(r.productivityRatio*100).toFixed(1)}%`],
          ['Daily Avg Sleep', this.app.formatDuration(r.dailyAverageSleep)],
          ['Daily Avg Productive', this.app.formatDuration(r.dailyAverageProductive)],
          ['Improvement vs Previous Month', `Productive ${this.app.formatDuration(r.improvement.productiveDeltaMinutes)} | Waste ${this.app.formatDuration(r.improvement.wasteDeltaMinutes)}`],
          ['Best Productive Day', best],
          ['Worst Waste Day', worst],
          ['Sleep Consistency', `Longest >=7h streak: ${r.sleepConsistency.longestStreakDays} days`],
          ['Sleep Last 7 Days', `Avg ${this.app.formatDuration(sleepInsights.averageLast7)} | ${sleepInsights.sleepDebt > 0 ? `Debt ${this.app.formatDuration(sleepInsights.sleepDebt)}` : `Surplus ${this.app.formatDuration(Math.abs(sleepInsights.sleepDebt))}`} | Consistency ${sleepInsights.consistency}`],
          ['Alerts', r.alerts.underProductivity ? `Under productivity (${r.alerts.underProductiveDays} days below ${this.app.formatDuration(r.alerts.thresholdMinutes)})` : 'None']
        ].map(([label, value]) => `<tr><td style="padding:0.75rem;border-bottom:1px solid var(--border);font-weight:600;">${label}</td><td style="padding:0.75rem;border-bottom:1px solid var(--border);">${value}</td></tr>`).join('');
        this.app.elements['report-content'].innerHTML = `
          <h3 style="margin-bottom:1rem;">${monthName} ${r.year} Monthly Report</h3>
          <h4 style="margin-top:1rem;">Summary</h4>
          <div style="overflow-x:auto;"><table style="width:100%;border-collapse:collapse;"><tbody>${summaryRows}</tbody></table></div>
          <h4 style="margin-top:1rem;">Category Totals</h4>
          <div style="overflow-x:auto;"><table style="width:100%;border-collapse:collapse;"><thead><tr style="background: rgba(30, 30, 30, 0.8);"><th style="padding:0.75rem;text-align:left;border-bottom:1px solid var(--border);">Category</th><th style="padding:0.75rem;text-align:left;border-bottom:1px solid var(--border);">Duration</th><th style="padding:0.75rem;text-align:left;border-bottom:1px solid var(--border);">Share</th></tr></thead><tbody>${catRows}</tbody></table></div>
          <h4 style="margin-top:1rem;">Productive Work Breakdown</h4>
          <div style="overflow-x:auto;"><table style="width:100%;border-collapse:collapse;"><thead><tr style="background: rgba(30, 30, 30, 0.8);"><th style="padding:0.75rem;text-align:left;border-bottom:1px solid var(--border);">Subcategory</th><th style="padding:0.75rem;text-align:left;border-bottom:1px solid var(--border);">Duration</th></tr></thead><tbody>${prodBreak}</tbody></table></div>
          <h4 style="margin-top:1rem;">Physical Training Breakdown</h4>
          <div style="overflow-x:auto;"><table style="width:100%;border-collapse:collapse;"><thead><tr style="background: rgba(30, 30, 30, 0.8);"><th style="padding:0.75rem;text-align:left;border-bottom:1px solid var(--border);">Subcategory</th><th style="padding:0.75rem;text-align:left;border-bottom:1px solid var(--border);">Duration</th></tr></thead><tbody>${trainBreak}</tbody></table></div>
          <h4>Daily Breakdown</h4>
          <div style="overflow-x:auto;"><table style="width:100%;border-collapse:collapse;"><thead><tr style="background: rgba(30, 30, 30, 0.8);"><th style="padding:0.75rem;text-align:left;border-bottom:1px solid var(--border);">Date</th><th style="padding:0.75rem;text-align:left;border-bottom:1px solid var(--border);">Productive</th><th style="padding:0.75rem;text-align:left;border-bottom:1px solid var(--border);">Sleep</th><th style="padding:0.75rem;text-align:left;border-bottom:1px solid var(--border);">Total Waste</th></tr></thead><tbody>${rows}</tbody></table></div>`;
        this.app.elements['report-modal'].style.display = 'flex';
      }
      hideReport() { this.app.elements['report-modal'].style.display = 'none'; }
      exportData() {
        const now = new Date();
        const report = AnalyticsService.buildMonthlyReport(this.app.state.tasks, now.getFullYear(), now.getMonth());
        const csvContent = [
          ['Date','Category','Subcategory','Start Time','End Time','Duration (minutes)','Description'].join(','),
          ...this.app.state.tasks.map(task => [task.date,`"${task.category}"`,`"${task.subcategory}"`,new Date(task.startTime).toLocaleString(),new Date(task.endTime).toLocaleString(),task.duration,`"${(task.description || '').replace(/"/g,'""')}"`].join(','))
        ].join('\n');
        const csvBlob = new Blob([csvContent], { type: 'text/csv' });
        const jsonBlob = new Blob([JSON.stringify({ schemaVersion: CONFIG.DB_SCHEMA_VERSION, exportedAt: new Date().toISOString(), entries: this.app.state.tasks, monthlyReport: report }, null, 2)], { type: 'application/json' });
        [['csv', csvBlob], ['json', jsonBlob]].forEach(([ext, blob]) => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url; a.download = `discipline-data-${this.app.getDateString()}.${ext}`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        });
      }
    }

    class ShadowEngine {
      constructor(app) {
        this.app = app;
        this.shadowSevenDayAverage = 0;
        this.rankTiers = [
          { min: 0, title: 'Initiate', badge: 'Baseline' },
          { min: 120, title: 'Builder', badge: 'Builder' },
          { min: 180, title: 'Operator', badge: 'Operator' },
          { min: 240, title: 'Executor', badge: 'Executor' },
          { min: 300, title: 'Elite', badge: 'Elite' },
          { min: 360, title: 'Apex', badge: 'Apex' },
          { min: 420, title: 'Overdrive', badge: 'Legend' }
        ];
      }

      initialize() {
        const stored = parseFloat(this.app.loadFromStorage(CONFIG.STORAGE_KEYS.SHADOW_AVG));
        this.shadowSevenDayAverage = Number.isFinite(stored) ? stored : 0;
        this.refresh(false);
      }

      getDailyProductiveMap() {
        const dailyMap = new Map();
        this.app.state.tasks.forEach(task => {
          if (!this.app.isProductiveCategory(task.category)) return;
          dailyMap.set(task.date, (dailyMap.get(task.date) || 0) + task.duration);
        });
        return dailyMap;
      }

      getTodayGoalProgress() {
        const today = this.app.getDateString(new Date());
        const goals = CONFIG.DAILY_GOALS || [];
        const progress = {};

        goals.forEach(goal => {
          progress[goal.id] = { minutes: 0, sessions: 0, minutesTarget: goal.minutesTarget || 0, sessionsTarget: goal.sessionsTarget || 0 };
        });

        this.app.state.tasks.forEach(task => {
          if (!task || task.date !== today || !Number.isFinite(task.duration) || task.duration <= 0) return;
          const haystack = `${task.description || ''} ${task.subcategory || ''} ${task.category || ''}`.toLowerCase();
          goals.forEach(goal => {
            if (!goal.keywords?.some(word => haystack.includes(word))) return;
            progress[goal.id].minutes += task.duration;
            progress[goal.id].sessions += 1;
          });
        });

        return progress;
      }

      formatGoalProgress(goal, progress) {
        const minutesText = this.app.formatDuration(progress.minutes);
        if (goal.sessionsTarget > 0) return `${minutesText} â€¢ ${progress.sessions}/${goal.sessionsTarget}`;
        return minutesText;
      }

      applyGoalStatus(elementId, goal, progress) {
        const el = this.app.elements[elementId];
        if (!el) return;
        const hitMinutes = progress.minutes >= goal.minutesTarget;
        const hitSessions = goal.sessionsTarget > 0 ? progress.sessions >= goal.sessionsTarget : true;
        const done = hitMinutes && hitSessions;
        el.textContent = this.formatGoalProgress(goal, progress);
        el.classList.toggle('shadow-goal-done', done);
      }

      buildDailyProductiveSeries() {
        const dailyMap = this.getDailyProductiveMap();
        if (dailyMap.size === 0) return [];

        const sorted = [...dailyMap.keys()].sort();
        const start = new Date(sorted[0]);
        const end = new Date(this.app.getDateString());
        const series = [];

        for (let cursor = new Date(start); cursor <= end; cursor.setDate(cursor.getDate() + 1)) {
          const key = this.app.getDateString(cursor);
          series.push(dailyMap.get(key) || 0);
        }
        return series;
      }

      computeRollingMetrics() {
        const series = this.buildDailyProductiveSeries();
        if (!series.length) return { bestAvg: 0, currentAvg: 0, previousAvg: 0, todayMinutes: 0, hasMomentumBaseline: false };

        const prefix = new Array(series.length + 1).fill(0);
        for (let i = 0; i < series.length; i++) prefix[i + 1] = prefix[i] + series[i];

        const lastIdx = series.length - 1;
        const todayMinutes = series[lastIdx] || 0;

        // Historical shadow excludes today (completed history only)
        const historicalEnd = Math.max(0, lastIdx);
        let bestAvg = 0;
        if (historicalEnd > 0) {
          if (historicalEnd < 7) bestAvg = prefix[historicalEnd] / 7;
          else {
            for (let i = 7; i <= historicalEnd; i++) {
              const avg = (prefix[i] - prefix[i - 7]) / 7;
              if (avg > bestAvg) bestAvg = avg;
            }
          }
        }

        const endIdx = series.length;
        const currentAvg = (prefix[endIdx] - prefix[Math.max(0, endIdx - 7)]) / 7;

        const prevEnd = Math.max(0, endIdx - 7);
        const prevStart = Math.max(0, prevEnd - 7);
        const previousAvg = prevEnd > 0 ? (prefix[prevEnd] - prefix[prevStart]) / 7 : 0;
        const hasMomentumBaseline = (prevEnd - prevStart) >= 4;

        return { bestAvg, currentAvg, previousAvg, todayMinutes, hasMomentumBaseline };
      }

      getShadowRank(minutes) {
        let selected = this.rankTiers[0];
        for (const tier of this.rankTiers) if (minutes >= tier.min) selected = tier;
        return selected;
      }

      getCurrentStatus(percentage) {
        if (percentage >= 100) return 'STANDARD BROKEN';
        if (percentage >= 90) return 'AT THE GATE';
        if (percentage >= 70) return 'TRAILING';
        return 'OUT OF RANGE';
      }

      getProgressStyle(percentage) {
        if (percentage >= 100) return { color: '#28a745', shadow: '0 0 12px rgba(40,167,69,0.45)' };
        if (percentage >= 90) return { color: '#007bff', shadow: 'none' };
        if (percentage >= 70) return { color: '#ffc107', shadow: 'none' };
        return { color: '#dc3545', shadow: 'none' };
      }

      getMomentum(currentAvg, previousAvg, hasBaseline) {
        if (!hasBaseline) return { label: 'Insufficient history', cls: 'shadow-momentum-flat' };
        const delta = currentAvg - previousAvg;
        if (delta > 8) return { label: `Rising (+${this.app.formatDuration(delta)})`, cls: 'shadow-momentum-positive' };
        if (delta < -8) return { label: `Drifting (-${this.app.formatDuration(Math.abs(delta))})`, cls: 'shadow-momentum-negative' };
        return { label: 'Stable', cls: 'shadow-momentum-flat' };
      }

      getPressure(percentage, weeklyGap, recentWinRate) {
        // Penalty-only pressure model: no positive buff reductions.
        const weeklyPenalty = weeklyGap > 0 ? 1 : 0;
        const trendPenalty = recentWinRate < 0.35 ? 2 : (recentWinRate < 0.55 ? 1 : 0);

        let level = 0; // 0 controlled, 1 elevated, 2 high, 3 critical
        if (percentage >= 100) level = 0;
        else if (percentage >= 90) level = 1;
        else if (percentage >= 70) level = 2;
        else level = 3;

        level = Math.min(3, level + weeklyPenalty + trendPenalty);

        if (level <= 0) return { label: 'Pressure: Controlled', cls: 'shadow-pressure-low' };
        if (level === 1) return { label: 'Pressure: Elevated', cls: 'shadow-pressure-mid' };
        if (level === 2) return { label: 'Pressure: High', cls: 'shadow-pressure-mid' };
        return { label: 'Pressure: Critical', cls: 'shadow-pressure-high' };
      }

      countShadowWinsThisMonth(dailyMap, shadowAvg) {
        if (shadowAvg <= 0) return { myWins: 0, shadowWins: 0, activeDays: 0, recentWinRate: 0 };
        const now = new Date();
        const month = now.getMonth();
        const year = now.getFullYear();
        const monthDays = [];
        let myWins = 0;
        let activeDays = 0;

        for (const [date, minutes] of dailyMap.entries()) {
          const d = new Date(date);
          if (d.getFullYear() !== year || d.getMonth() !== month) continue;
          activeDays += 1;
          const isWin = minutes >= shadowAvg;
          if (isWin) myWins++;
          monthDays.push({ date, isWin });
        }

        monthDays.sort((a, b) => a.date.localeCompare(b.date));
        const recent = monthDays.slice(-7);
        const recentWins = recent.filter(d => d.isWin).length;
        const recentWinRate = recent.length ? (recentWins / recent.length) : 0;

        const shadowWins = Math.max(0, activeDays - myWins);
        return { myWins, shadowWins, activeDays, recentWinRate };
      }

      getPenalty(todayMinutes, shadowAvg, weeklyGap, recentWinRate) {
        let points = 0;
        if (todayMinutes < shadowAvg) points += 1;
        if (weeklyGap > 0) points += 1;
        if (recentWinRate < 0.5) points += 1;
        const today = this.app.getDateString();
        const untracked = this.app.getInferredWasteMinutesForDate(today, this.app.state.tasks);
        if (untracked >= 300) points += 2;
        else if (untracked >= 120) points += 1;
        const minutes = points * 15;
        return { points, minutes, untracked };
      }

      render({ todayMinutes, shadowAvg, currentAvg, previousAvg, hasMomentumBaseline, isNewStandard }) {
        const safeShadow = shadowAvg > 0 ? shadowAvg : 1;
        const gap = shadowAvg - todayMinutes;
        const weeklyGap = shadowAvg - currentAvg;
        const percentage = (todayMinutes / safeShadow) * 100;

        const dailyMap = this.getDailyProductiveMap();
        const competition = this.countShadowWinsThisMonth(dailyMap, shadowAvg);
        const scoreDiff = competition.myWins - competition.shadowWins;
        const targetToday = shadowAvg > 0 ? Math.ceil(shadowAvg + 1) : 0;
        const neededTie = Math.max(0, shadowAvg - todayMinutes);
        const neededLead = Math.max(0, shadowAvg - todayMinutes + 1);
        const penalty = this.getPenalty(todayMinutes, shadowAvg, weeklyGap, competition.recentWinRate);
        const defenseTarget = Math.max(0, Math.ceil(shadowAvg + penalty.minutes));
        const totalDuel = Math.max(1, competition.myWins + competition.shadowWins);
        const youShare = Math.max(0, Math.min(100, (competition.myWins / totalDuel) * 100));
        const shadowShare = Math.max(0, Math.min(100, (competition.shadowWins / totalDuel) * 100));

        this.app.elements['shadow-current-minutes'].textContent = this.app.formatDuration(todayMinutes);
        this.app.elements['shadow-average'].textContent = this.app.formatDuration(shadowAvg);
        this.app.elements['shadow-weekly-average'].textContent = this.app.formatDuration(currentAvg);
        this.app.elements['shadow-target'].textContent = this.app.formatDuration(targetToday);
        this.app.elements['shadow-needed-tie'].textContent = this.app.formatDuration(neededTie);
        this.app.elements['shadow-needed-lead'].textContent = this.app.formatDuration(neededLead);
        this.app.elements['shadow-defense-target'].textContent = this.app.formatDuration(defenseTarget);
        this.app.elements['shadow-penalty'].textContent = `-${this.app.formatDuration(penalty.minutes)} (${penalty.points}pt)`;
        this.app.elements['shadow-weekly-gap'].textContent = `${weeklyGap >= 0 ? '-' : '+'}${this.app.formatDuration(Math.abs(weeklyGap))}`;
        this.app.elements['shadow-weekly-gap'].className = weeklyGap > 0 ? 'shadow-gap-positive' : (weeklyGap < 0 ? 'shadow-gap-negative' : 'shadow-gap-equal');

        const momentum = this.getMomentum(currentAvg, previousAvg, hasMomentumBaseline);
        const momentumEl = this.app.elements['shadow-momentum'];
        momentumEl.textContent = momentum.label;
        momentumEl.className = momentum.cls;

        this.app.elements['shadow-percent'].textContent = `${percentage.toFixed(1)}%`;
        const gapEl = this.app.elements['shadow-gap'];
        gapEl.textContent = `${gap >= 0 ? '-' : '+'}${this.app.formatDuration(Math.abs(gap))}`;
        gapEl.className = gap > 0 ? 'shadow-gap-positive' : (gap < 0 ? 'shadow-gap-negative' : 'shadow-gap-equal');

        this.app.elements['shadow-status'].textContent = this.getCurrentStatus(percentage);
        const pressure = this.getPressure(percentage, weeklyGap, competition.recentWinRate);
        const pressureEl = this.app.elements['shadow-pressure'];
        pressureEl.textContent = pressure.label;
        pressureEl.className = `shadow-badge ${pressure.cls}`;

        const rank = this.getShadowRank(shadowAvg);
        this.app.elements['shadow-rank'].textContent = `Rank: ${rank.title}`;
        this.app.elements['shadow-badge'].textContent = rank.badge;
        this.app.elements['shadow-score'].textContent = `Monthly Score: You ${competition.myWins} - Shadow ${competition.shadowWins}`;
        this.app.elements['shadow-duel'].textContent = scoreDiff > 0 ? `Leader: You (+${scoreDiff})` : (scoreDiff < 0 ? `Leader: Shadow (+${Math.abs(scoreDiff)})` : 'Leader: Even');
        this.app.elements['shadow-lead-margin'].textContent = `Lead Margin: ${Math.abs(scoreDiff)}`;
        this.app.elements['shadow-trend'].textContent = `Monthly trend: ${(competition.recentWinRate * 100).toFixed(0)}% win rate`;
        this.app.elements['shadow-verdict'].textContent = scoreDiff >= 0
          ? `You lead monthly by ${Math.abs(scoreDiff)} win(s); hold at least ${this.app.formatDuration(defenseTarget)} tomorrow (penalty-adjusted).`
          : `You are behind by ${this.app.formatDuration(neededTie)} today and ${Math.abs(scoreDiff)} monthly win(s).`;

        const goalProgress = this.getTodayGoalProgress();
        this.applyGoalStatus('goal-nptel', CONFIG.DAILY_GOALS[0], goalProgress.nptel || { minutes: 0, sessions: 0, minutesTarget: 120, sessionsTarget: 2 });
        this.applyGoalStatus('goal-yt', CONFIG.DAILY_GOALS[1], goalProgress.yt || { minutes: 0, sessions: 0, minutesTarget: 120, sessionsTarget: 2 });
        this.applyGoalStatus('goal-project', CONFIG.DAILY_GOALS[2], goalProgress.project || { minutes: 0, sessions: 0, minutesTarget: 180, sessionsTarget: 0 });

        this.app.elements['shadow-duel-you-fill'].style.width = `${youShare}%`;
        this.app.elements['shadow-duel-shadow-fill'].style.width = `${shadowShare}%`;
        this.app.elements['shadow-note'].textContent = 'Calculated from real historical data only';

        const fill = this.app.elements['shadow-progress-fill'];
        const cappedWidth = Math.min(130, Math.max(0, percentage));
        const style = this.getProgressStyle(percentage);
        fill.style.width = `${cappedWidth}%`;
        fill.style.background = style.color;
        fill.style.boxShadow = style.shadow;

        if (isNewStandard) {
          const card = this.app.elements['shadow-standard-card'];
          card.classList.remove('shadow-new-standard');
          void card.offsetWidth;
          card.classList.add('shadow-new-standard');
        }
      }

      refresh(allowAnimation = true) {
        const metrics = this.computeRollingMetrics();
        const historicalBest = metrics.bestAvg;
        const resolvedShadow = Math.max(this.shadowSevenDayAverage, historicalBest);
        const isNewStandard = resolvedShadow > this.shadowSevenDayAverage;

        if (resolvedShadow !== this.shadowSevenDayAverage) {
          this.shadowSevenDayAverage = resolvedShadow;
          this.app.saveToStorage(CONFIG.STORAGE_KEYS.SHADOW_AVG, resolvedShadow);
        }

        this.render({
          todayMinutes: metrics.todayMinutes,
          shadowAvg: resolvedShadow,
          currentAvg: metrics.currentAvg,
          previousAvg: metrics.previousAvg,
          hasMomentumBaseline: metrics.hasMomentumBaseline,
          isNewStandard: allowAnimation && isNewStandard
        });
      }
    }

    class GraphManager {
      constructor(app) { this.app = app; this.charts = { productivity: null, sleep: null }; this.totalCounterAnimation = null; this.lastFilteredTotalMinutes = 0; }
      initialize() { if (!window.Chart) return; this.createCharts(); this.setupChartControls(); this.lastFilteredTotalMinutes = this.getCurrentFilteredTotalMinutes(); this.animateFilteredTotal(0, this.lastFilteredTotalMinutes); }

      getCurrentFilter() {
        return this.app.elements['prod-filter']?.value || 'all';
      }

      passesProductivityFilter(task, filter) {
        if (task.category === 'Sleep') return false;
        const tag = task.graph_tag || 'neutral';
        const waste = task.waste_level || 'NONE';
        if (filter === 'all') return true;
        if (filter === 'productivity') return tag === 'productivity';
        if (filter === 'distraction') return tag === 'distraction';
        if (filter === 'neutral') return tag === 'neutral';
        if (filter === 'high_waste') return waste === 'HIGH';
        return true;
      }

      getColorScheme(filter) {
        if (filter === 'productivity') return { border: 'rgb(40, 180, 99)', fill: 'rgba(40, 180, 99, 0.16)' };
        if (filter === 'distraction' || filter === 'high_waste') return { border: 'rgb(220, 53, 69)', fill: 'rgba(220, 53, 69, 0.16)' };
        if (filter === 'neutral') return { border: 'rgb(148, 163, 184)', fill: 'rgba(148, 163, 184, 0.14)' };
        return { border: 'rgb(0,123,255)', fill: 'rgba(0,123,255,0.12)' };
      }

      createCharts() {
        const prodCtx = this.app.elements['productivity-chart'].getContext('2d');
        this.charts.productivity = new Chart(prodCtx, {
          type: 'line',
          data: this.getProductivityData('7d', this.getCurrentFilter()),
          options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: { duration: 420, easing: 'easeOutCubic' },
            transitions: {
              active: { animation: { duration: 320 } },
              resize: { animation: { duration: 320 } }
            },
            plugins: { legend: { display: false } },
            scales: { y: { beginAtZero: true, ticks: { callback: v => v + 'h' } } },
            elements: {
              point: {
                radius: 0,
                hoverRadius: 0,
                pointStyle: 'circle',
                hoverBorderWidth: 2
              },
              line: { tension: 0.34, borderWidth: 2.5 }
            }
          }
        });

        const sleepCtx = this.app.elements['sleep-chart'].getContext('2d');
        this.charts.sleep = new Chart(sleepCtx, {
          type: 'bar',
          data: this.getSleepData('7d'),
          options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: { duration: 380, easing: 'easeOutQuad' },
            plugins: { legend: { display: false } },
            scales: { y: { beginAtZero: true, max: 12, ticks: { callback: v => v + 'h' } } }
          }
        });
      }

      getProductivityData(range='7d', filter='all') {
        const days = CONFIG.CHART_RANGES[range] || 7, data=[], labels=[], today=new Date();
        for (let i=days-1;i>=0;i--) {
          const d=new Date(today);
          d.setDate(today.getDate()-i);
          const ds=this.app.getDateString(d);
          const mins=this.app.state.tasks
            .filter(t => t.date===ds && this.passesProductivityFilter(t, filter))
            .reduce((a,t)=>a+t.duration,0);
          labels.push(d.toLocaleDateString('en-US',{month:'short',day:'numeric'}));
          data.push(parseFloat((mins/60).toFixed(2)));
        }
        const colors = this.getColorScheme(filter);
        return {
          labels,
          datasets: [{
            label:'Tracked Hours',
            data,
            borderColor: colors.border,
            backgroundColor: colors.fill,
            pointBackgroundColor: colors.border,
            pointBorderColor: 'rgba(255,255,255,0.65)',
            pointHoverBackgroundColor: '#ffffff',
            pointHoverBorderColor: colors.border,
            fill:true
          }]
        };
      }

      getSleepData(range='7d') {
        const days = CONFIG.CHART_RANGES[range] || 7, data=[], labels=[], today=new Date();
        for (let i=days-1;i>=0;i--) { const d=new Date(today); d.setDate(today.getDate()-i); const ds=this.app.getDateString(d); const mins=this.app.state.tasks.filter(t => t.date===ds && t.category==='Sleep').reduce((a,t)=>a+t.duration,0); labels.push(d.toLocaleDateString('en-US',{month:'short',day:'numeric'})); data.push(parseFloat((mins/60).toFixed(1))); }
        return { labels, datasets: [{ label:'Sleep Hours', data, backgroundColor:'rgba(111, 66, 193, 0.7)', borderColor:'rgb(111,66,193)', borderWidth:1, borderRadius:4 }] };
      }

      getCurrentFilteredTotalMinutes() {
        const filter = this.getCurrentFilter();
        const range = this.app.elements['prod-range'].value;
        const days = CONFIG.CHART_RANGES[range] || 7;
        const start = new Date();
        start.setDate(start.getDate() - (days - 1));
        const startDate = this.app.getDateString(start);
        return this.app.state.tasks
          .filter(t => t.date >= startDate && this.passesProductivityFilter(t, filter))
          .reduce((sum, t) => sum + t.duration, 0);
      }

      animateFilteredTotal(fromMinutes, toMinutes) {
        if (!this.app.elements['prod-filter-total']) return;
        const el = this.app.elements['prod-filter-total'];
        const start = performance.now();
        const duration = 450;
        const tick = (now) => {
          const progress = Math.min(1, (now - start) / duration);
          const eased = 1 - Math.pow(1 - progress, 3);
          const current = fromMinutes + (toMinutes - fromMinutes) * eased;
          el.textContent = this.app.formatDuration(current);
          if (progress < 1) this.totalCounterAnimation = requestAnimationFrame(tick);
        };
        if (this.totalCounterAnimation) cancelAnimationFrame(this.totalCounterAnimation);
        this.totalCounterAnimation = requestAnimationFrame(tick);
      }

      updateCharts() {
        if (!this.charts.productivity || !this.charts.sleep) return;
        const prodRange = this.app.elements['prod-range'].value;
        const sleepRange = this.app.elements['sleep-range'].value;
        const filter = this.getCurrentFilter();

        const prodContainer = this.app.elements['productivity-chart'].closest('.graph-canvas-container');
        if (prodContainer) prodContainer.classList.add('filter-updating');

        const fromMinutes = this.lastFilteredTotalMinutes;
        this.charts.productivity.data=this.getProductivityData(prodRange, filter);
        this.charts.sleep.data=this.getSleepData(sleepRange);
        this.charts.productivity.update();
        this.charts.sleep.update();

        const toMinutes = this.getCurrentFilteredTotalMinutes();
        this.lastFilteredTotalMinutes = toMinutes;
        this.animateFilteredTotal(fromMinutes, toMinutes);
        setTimeout(() => { if (prodContainer) prodContainer.classList.remove('filter-updating'); }, 360);
      }

      setupChartControls() {
        this.app.elements['prod-range'].addEventListener('change', () => this.updateCharts());
        this.app.elements['prod-filter'].addEventListener('change', () => this.updateCharts());
        this.app.elements['sleep-range'].addEventListener('change', () => this.updateCharts());
      }
    }
    class EventManager {
      constructor(app) { this.app = app; }
      initialize() { this.bindEvents(); }
      bindEvents() {
        this.app.elements['start-btn'].addEventListener('click', () => this.app.stopwatch.start());
        this.app.elements['stop-btn'].addEventListener('click', () => this.app.stopwatch.stop());
        this.app.elements['sleep-btn'].addEventListener('click', () => this.app.stopwatch.startSleep());
        this.app.elements['add-favorite'].addEventListener('click', () => this.app.taskManager.addFavorite());
        this.app.elements['task-input'].addEventListener('keypress', e => { if (e.key === 'Enter' && !this.app.stopwatch.isRunning) this.app.stopwatch.start(); });
        this.app.elements['view-report'].addEventListener('click', () => this.app.uiManager.showReport());
        this.app.elements['export-data'].addEventListener('click', () => this.app.uiManager.exportData());
        this.app.elements['close-modal'].addEventListener('click', () => this.app.uiManager.hideReport());
        this.app.elements['close-report'].addEventListener('click', () => this.app.uiManager.hideReport());
        this.app.elements['print-report'].addEventListener('click', () => window.print());
        this.app.elements['close-streak'].addEventListener('click', () => this.app.uiManager.hideStreakPopup());
        this.app.elements['report-modal'].addEventListener('click', e => { if (e.target === this.app.elements['report-modal']) this.app.uiManager.hideReport(); });
      }
    }
    window.classifyActivity = (userInput) => ActivityClassifier.classify(userInput);
    window.app = new DisciplineTracker();
    document.addEventListener('DOMContentLoaded', () => window.app.initialize());
    document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'visible' && window.app.taskManager) { window.app.taskManager.updateStats(); window.app.taskManager.renderTasks(); window.app.taskManager.renderFavorites(); if (window.app.shadowEngine) window.app.shadowEngine.refresh(false); } });
    window.addEventListener('beforeunload', () => { if (window.app?.stopwatch?.animationFrameId) cancelAnimationFrame(window.app.stopwatch.animationFrameId); });
  </script>
</body>
</html>
